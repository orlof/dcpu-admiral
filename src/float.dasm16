;----------------------------------------------------------------
; void float_create(uint category, uint exponent, uint mantissa_pattern)
;----------------------------------------------------------------
:float_create
    set push, 3
    set push, 1
    jsr preamble
    
    set push, SIZEOF_FLOAT
    set push, TYPE_FLOAT
    jsr alloc
    set [z-1], x
    
    set i, [x]
    sti [i], [z+12]
    sti [i], [z+11]

    set a, i
    add a, FLOAT_MANTISSA_WORDS - 1

:float_create_loop
    set [i], [z+10]
    ifl i, a
        sti pc, float_create_loop    

    set push, [builtin]
    set push, x
    jsr array__append

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
; void float_init(void)
;----------------------------------------------------------------
:float_init
    set push, 0
    set push, 1
    jsr preamble
    
    set push, FLOAT_CATEGORY_NAN
    set push, 0xffff
    set push, 0xffff
    jsr float_create
    set [FLOAT_NAN], x

    set push, FLOAT_CATEGORY_PINF
    set push, 0xffff
    set push, 0x0000
    jsr float_create
    set [FLOAT_PINF], x
    
    set push, FLOAT_CATEGORY_NINF
    set push, 0xffff
    set push, 0x0000
    jsr float_create
    set [FLOAT_NINF], x

    set push, FLOAT_CATEGORY_PZERO
    set push, 0x0000
    set push, 0x0000
    jsr float_create
    set [FLOAT_PZERO], x
    
    set push, FLOAT_CATEGORY_NZERO
    set push, 0x0000
    set push, 0x0000
    jsr float_create
    set [FLOAT_NZERO], x

    set i, 0
    set j, FLOAT_0
    
:float_init_loop
    set push, i
    jsr float_from_uint
    set [z-1], x
    set [j], x

    set push, [builtin]
    set push, x
    jsr array__append

    ifl i, 10
        sti pc, float_init_loop

    set pc, postamble

;----------------------------------------------------------------
; struct handle *float_cmp(struct handle *left, struct handle *right)
;----------------------------------------------------------------
:float_cmp__float_int
    set push, 2
    set push, 1
    jsr preamble

    set push, [z + 10]
    jsr float_from_int
    set [z-1], x

    set push, [z + 11]
    set push, [z - 1]
    jsr float_cmp

    set pc, postamble

;----------------------------------------------------------------
; struct handle *float_cmp(struct handle *left, struct handle *right)
;----------------------------------------------------------------
:float_cmp__int_float
    set push, 2
    set push, 1
    jsr preamble

    set push, [z + 11]
    jsr float_from_int
    set [z-1], x

    set push, [z - 1]
    set push, [z + 10]
    jsr float_cmp

    set pc, postamble

;----------------------------------------------------------------
; struct handle *float_cmp(struct handle *left, struct handle *right)
;----------------------------------------------------------------
:float_cmp
    set push, 2
    set push, 0
    jsr preamble

    set i, [z+11]
    set i, [i]

    set j, [z+10]
    set j, [j]

    ; sort arg1 - reorder -0 and -inf
    set a, [i + FLOAT_CATEGORY]
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NINF
        set a, FLOAT_CATEGORY_NZERO
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NZERO
        set a, FLOAT_CATEGORY_NINF

    ; move nan to msb
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
        set a, 0x8000

    ; sort arg1 - reorder -0 and -inf
    set b, [j + FLOAT_CATEGORY]
    ife [j + FLOAT_CATEGORY], FLOAT_CATEGORY_NINF
        set b, FLOAT_CATEGORY_NZERO
    ife [j + FLOAT_CATEGORY], FLOAT_CATEGORY_NZERO
        set b, FLOAT_CATEGORY_NINF

    ; move nan to msb
    ife [j + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
        set b, 0x8000

    ;---------------------------------------
    ; compare categories
    ;---------------------------------------
    set x, 1
    ifg a, b
        set pc, postamble

    set x, -1
    ifl a, b
        set pc, postamble

    ; numbers are in the same non-number category
    set x, 0
    ifc a, FLOAT_CATEGORY_PNUM + FLOAT_CATEGORY_NNUM
        set pc, postamble

    ;---------------------------------------
    ; compare positive or negative numbers
    ;---------------------------------------
    sti c, i
    add c, FLOAT_MANTISSA_WORDS + 1        ; last word of mantissa
    
:float_cmp_loop
    ifg [i], [j]
        set pc, float_cmp_gt

    ifl [i], [j]
        set pc, float_cmp_lt

    ifl i, c
        sti pc, float_cmp_loop

    ; numbers are equal
    set x, 0
    set pc, postamble

:float_cmp_gt
    set x, 1
    ifb a, FLOAT_MASK_NEGATIVE
        set x, -1
    set pc, postamble

:float_cmp_lt
    set x, -1
    ifb b, FLOAT_MASK_NEGATIVE
        set x, 1
    set pc, postamble

;----------------------------------------------------------------
; struct handle *float_clone(struct handle *f)
;----------------------------------------------------------------
:float_clone
    set push, 1
    set push, 1
    jsr preamble
    
    set push, SIZEOF_FLOAT
    set push, TYPE_FLOAT
    jsr alloc
    set [z-1], x

    set i, [z+10]
    set i, [i]
    add i, SIZEOF_FLOAT - 1
    
    set j, x
    set j, [j]
    add j, SIZEOF_FLOAT - 1
    
:float_clone_loop
    set [j], [i]
    ifg j, [x]
        std pc, float_clone_loop

    set pc, postamble
    
;----------------------------------------------------------------
; struct handle *float_add(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_add
    set push, 2
    set push, 3
    jsr preamble

    set i, [z+11]
    set i, [i]
    
    set j, [z+10]
    set j, [j]

    ;---------------------------------------
    ; check special cases
    ;---------------------------------------
    set a, [i + FLOAT_CATEGORY]
    bor a, [j + FLOAT_CATEGORY]

    ; if arg1 or arg2 is nan    
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
        set pc, float_postamble_nan
    ife [j + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
        set pc, float_postamble_nan
    
    ; if args are +inf and -inf    
    ife a, FLOAT_CATEGORY_PINF + FLOAT_CATEGORY_NINF
        set pc, float_postamble_nan

    ; if arg1 or arg2 is +inf
    ifb a, FLOAT_CATEGORY_PINF
        set pc, float_postamble_pinf

    ; if arg1 or arg2 is -inf
    ifb a, FLOAT_CATEGORY_NINF
        set pc, float_postamble_ninf

    ;---------------------------------------
    ; [z-1] = abs([z+11])
    ;---------------------------------------
    set push, [z+11]
    jsr float_abs
    set [z-1], x

    ;---------------------------------------
    ; [z-2] = abs([z+10])
    ;---------------------------------------
    set push, [z+10]
    jsr float_abs
    set [z-2], x

    ;---------------------------------------
    ; [z-2] = ([z-1] < [z-2]) ? [z+11]: [z+10]
    ; [z-1] = clone(([z-1] >= [z-2]) ? [z+11]: [z+10])
    ;---------------------------------------
    set push, [z-1]
    set push, [z-2]
    jsr float_cmp

    ife x, -1
        set [z-2], [z+11]
    ifn x, -1
        set [z-2], [z+10]

    ife x, -1
        set push, [z+10]
    ifn x, -1
        set push, [z+11]

    jsr float_clone
    set [z-1], x

    ;---------------------------------------
    ; align exponents
    ;---------------------------------------
    set i, [z-1]        ; struct handle *
    set i, [i]            ; struct float *max
    
    set j, [z-2]        ; struct handle *
    set j, [j]            ; struct float *min

    ; quick exit if [z-2] is zero
    ifb [j + FLOAT_CATEGORY], FLOAT_CATEGORY_PZERO + FLOAT_CATEGORY_NZERO
        set pc, float_postamble

    ; which method to use?
    set push, float_add_by_sub
    ife [j + FLOAT_CATEGORY], [i + FLOAT_CATEGORY]
        set [sp], float_add_by_add

    ; calculate exponent diff
    set a, [i + FLOAT_EXPONENT]
    sub a, [j + FLOAT_EXPONENT]
    
    ;---------------------------------------
    ; set x, y point to mantissa msw
    ;---------------------------------------
    set x, i
    add x, FLOAT_MANTISSA
    add i, FLOAT_MANTISSA + FLOAT_MANTISSA_WORDS - 1

    set y, j
    add y, FLOAT_MANTISSA
    add j, FLOAT_MANTISSA + FLOAT_MANTISSA_WORDS - 1

    ; calculate amount of word shifts
    set b, a
    div b, 16
    
    ; quick exit if arg2 is too small
    ifg b, FLOAT_MANTISSA_WORDS - 1
        set pc, float_postamble

    ; skip b lsw
    sub j, b

    ; calculate amount of bit shifts
    mod a, 16

    ; init carry with zero
    set c, 0

    ; init lsb part of 1st word
    set b, [j]
    shr b, a

    ; call add or sub (this is not rts)
    set pc, pop

:float_add_by_sub
    ;---------------------------------------
    ; loop that bit shifts and subtracts
    ;---------------------------------------
    sub [i], c
    ifn ex, 0
        set c, 1
        
    sub [i], b
    ifn ex, 0
        set c, 1
        
    set b, 0
    ifg j, y
        set b, [j-1]
        
    shr b, a
    sub [i], ex
    ifn ex, 0
        set c, 1
    
    ifg i, x
        std pc, float_add_by_sub

    set push, [z-1]
    jsr float_normalize
    
    set pc, postamble

:float_add_by_add
    set ex, c
    adx [i], b
    set c, ex
    
    set b, 0
    ifg j, y
        set b, [j-1]
        
    shr b, a
    add [i], ex
    bor c, ex
    
    ifg i, x
        std pc, float_add_by_add

    ife c, 0
        set pc, float_postamble

    add i, FLOAT_MANTISSA_WORDS - 1
    set y, i

:float_add_by_add_shift_loop
    shr [i], 1
    ifl i, y
        bor [i+1], ex
    ifg i, x
        std pc, float_add_by_add_shift_loop
        
    bor [i], 0x8000
    add [i-1], 1
    ifn ex, 0
        set pc, float_postamble_pinf
        
    set pc, float_postamble
    
;----------------------------------------------------------------
; struct handle *float_sub(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_sub
    set push, 2
    set push, 1
    jsr preamble

    set push, [z+10]
    jsr float_negate
    set [z-1], x

    set push, [z+11]
    set push, [z-1]
    jsr float_add

    set pc, postamble

;----------------------------------------------------------------
; struct handle *float_mul(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_mul
    set push, 2
    set push, 1
    jsr preamble

    set i, [z+11]        ; struct handle *f1
    set j, [z+10]        ; struct handle *f2

    ;---------------------------------------
    ; check special cases
    ;---------------------------------------
    set a, [i]            ; struct float *f1
    set b, [j]            ; struct float *f2
    
    set a, [a + FLOAT_CATEGORY]
    set b, [b + FLOAT_CATEGORY]

    ; arg1 or arg2 is nan    
    ife a, FLOAT_CATEGORY_NAN
        set pc, float_postamble_nan
    ife b, FLOAT_CATEGORY_NAN
        set pc, float_postamble_nan

    set c, a
    bor c, b

    ; one arg is zero and other is inf
    ifb c, FLOAT_CATEGORY_NINF + FLOAT_CATEGORY_PINF
        ifb c, FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
            set pc, float_postamble_nan

    set push, SIZEOF_FLOAT
    set push, TYPE_FLOAT
    jsr alloc
    set [z-1], x
    set y, [x]

    set i, [i]
    set j, [j]

    ; deduce result sign
    set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_PNUM
    ifb c, FLOAT_MASK_POSITIVE
        ifb c, FLOAT_MASK_NEGATIVE
            set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NNUM

    ; arg is inf, postamble with deduced sign
    ifb c, FLOAT_CATEGORY_NINF + FLOAT_CATEGORY_PINF
        set pc, float_postamble_inf
            
    ; arg is zero, postamble with deduced sign
    ifb c, FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
        set pc, float_postamble_zero

    ;---------------------------------------
    ; calculate exponent
    ;---------------------------------------
    ; is all this really needed to detect overflow?
    set a, [i + FLOAT_EXPONENT]
    sub a, 0x8000                ; remove bias

    set b, [j + FLOAT_EXPONENT]
    sub b, 0x8000                ; remove bias

    set c, a                    ; calculate sum to c
    add c, b
     
    xor a, c                    ; does arg1.exp and result.exp have different sign
    xor b, c                    ; does arg2.exp and result.exp have different sign
    and a, b                    ; both operands have different sign than sum

    ; value for overflow exit
    set b, float_postamble_zero            ; assume underflow as default 
    ifg [i + FLOAT_EXPONENT], 0x8000    ; if exp>0 then assume overflow
        set b, float_postamble_inf

    ifb a, 0x8000                ; finally test overflow
      set pc, b                    ; and act accordingly

    add c, 0x8001                ; restore bias
    set [y + FLOAT_EXPONENT], c    ; set exponent

    ;---------------------------------------
    ; calculate mantissa
    ;---------------------------------------

    ; reserve stack space for mantissa product
    set c, sp
    sub c, FLOAT_MANTISSA_WORDS + FLOAT_MANTISSA_WORDS

    ; init stack space with zero
:float_mul_mantissa_init_loop
    set push, 0
    ifg sp, c
        set pc, float_mul_mantissa_init_loop

    ; init variables for multiplication loop
    sti x, x                ; advance i and j
    set a, i                ; a: f1.exp *
    set b, j                ; b: f2.exp *
    add i, FLOAT_MANTISSA_WORDS    ; i: f1.lsw *
    add j, FLOAT_MANTISSA_WORDS    ; j: f2.lsw *
    add c, FLOAT_MANTISSA_WORDS + FLOAT_MANTISSA_WORDS -1    ; c: product.lsw *

:float_mul_words_loop
    set x, [j]
    mul x, [i]

    set y, ex        ; store product high
    add [c], x        ; add product low
    adx [c-1], y    ; add product high
    set x, ex

    set y, c        ; y: product current word
    sub y, 2
:float_mul_carry_loop
    ife x, 0
        set pc, float_mul_carry_break
    add [y], x
    set x, ex    
    sub y, 1
    set pc, float_mul_carry_loop

:float_mul_carry_break
    sub j, 1        ; move f2 towards msw
    sub c, 1        ; move product cword towards msw

    ifn j, b        ; if f2 cword not out of bounds
        set pc, float_mul_words_loop

    add j, FLOAT_MANTISSA_WORDS        ; set f2 cword back to lsw
    add c, FLOAT_MANTISSA_WORDS        ; move product cword back the same amount
    
    sub i, 1        ; move f1 cwords towards msw
    sub c, 1        ; move product cword towards msw
    
    ifn i, a        ; if f1 cword not out of bounds
        set pc, float_mul_words_loop

    ; all multiplications done here
    set x, [z-1]
    set y, [x]

    ifb [sp], 0x8000
        set pc, float_mul_finish

    sub [y + FLOAT_EXPONENT], 1

    set c, sp
    add c, FLOAT_MANTISSA_WORDS + FLOAT_MANTISSA_WORDS - 1
    set i, sp

:float_mul_shift_loop
    shl [i], 1
    ifg i, sp
        bor [i-1], ex
    
    ifl i, c
        sti pc, float_mul_shift_loop

:float_mul_finish
    set i, y
    add i, FLOAT_MANTISSA

    set c, i
    add c, FLOAT_MANTISSA_WORDS - 1
    
:float_mul_copy_loop
    set [i], pop
    ifl i, c
        sti pc, float_mul_copy_loop

    set pc, postamble
;----------------------------------------------------------------
; struct handle *float_div(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_div
    set push, 2
    set push, 3
    jsr preamble

    set i, [z+11]    ; struct handle *divident
    set j, [z+10]    ; struct handle *divisor

    ;---------------------------------------
    ; check special cases
    ;---------------------------------------
    set a, [i]        ; struct float *divident
    set a, [a + FLOAT_CATEGORY]

    set b, [j]        ; struct float *divisor
    set b, [b + FLOAT_CATEGORY]

    ; arg1 or arg2 is nan    
    ife a, FLOAT_CATEGORY_NAN
        set pc, float_postamble_nan
    ife b, FLOAT_CATEGORY_NAN
        set pc, float_postamble_nan

    ; arg1 and arg2 are zeros
    ifb a, FLOAT_CATEGORY_PZERO + FLOAT_CATEGORY_NZERO
        ifb b, FLOAT_CATEGORY_PZERO + FLOAT_CATEGORY_NZERO
            set pc, float_postamble_nan

    ; arg1 and arg2 are infs
    ifb a, FLOAT_CATEGORY_PINF + FLOAT_CATEGORY_NINF
        ifb b, FLOAT_CATEGORY_PINF + FLOAT_CATEGORY_NINF
            set pc, float_postamble_nan

    ; allocate memory for quotient
    set push, SIZEOF_FLOAT
    set push, TYPE_FLOAT
    jsr alloc
    set [z-1], x    ; struct handle *quotient
    set y, [x]        ; struct float *quotient

    set i, [i]        ; struct float *divident
    set j, [j]        ; struct float *divisor

    ; simplify detection of following special cases
    set c, a
    bor c, b

    ; deduce quotient sign
    set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_PNUM
    ifb c, FLOAT_MASK_POSITIVE
        ifb c, FLOAT_MASK_NEGATIVE
            set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NNUM

    ; if divident is inf, quotient is inf with deduced sign
    ifb a, FLOAT_CATEGORY_NINF + FLOAT_CATEGORY_PINF
        set pc, float_postamble_inf
            
    ; if divident is zero, quotient is zero with deduced sign
    ifb a, FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
        set pc, float_postamble_zero

    ; if divisor is inf, quotient is zero with deduced sign
    ifb b, FLOAT_CATEGORY_NINF + FLOAT_CATEGORY_PINF
        set pc, float_postamble_zero
            
    ; if divisor is zero, quotient is inf with deduced sign
    ifb b, FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
        set pc, float_postamble_inf

    ;---------------------------------------
    ; calculate exponent
    ;---------------------------------------
    ; is all this really needed to detect overflow?
    ; ...does this even work?
    set a, [i + FLOAT_EXPONENT]    ; divident exponent
    sub a, 0x8000                ; remove bias

    set b, [j + FLOAT_EXPONENT]    ; divisor exponent
    sub b, 0x8000                ; remove bias

    set c, a                    ; quotient.exp = divident.exp - divisor.exp
    sub c, b

    ; signed arithmetic overflow test
    ; c = a + b -> "((a ^ c) & (b ^ c)) < 0"
    xor b, a
    xor a, c
    and a, b

    ; prepare for overflow exit
    set x, float_postamble_zero
    ifg [i + FLOAT_EXPONENT], 0x8000
        set x, float_postamble_inf

    ifb a, 0x8000                ; finally test overflow
        set pc, x

    add c, 0x8000                ; restore bias
    set [y + FLOAT_EXPONENT], c    ; set quotient exponent

    set push, [z+11]            ; clone divident (because we need to modify it)
    jsr float_clone
    set [z-2], x

    ;---------------------------------------
    ; calculate mantissa
    ;---------------------------------------
    ; z-1 -> quotient (y)
    ; z-2 -> divident
    ; z+10 -> divisor

    ; c: quotient.mantissa.cur_word
    ; y: quotient.mantissa.lsw
    set c, y
    add c, FLOAT_MANTISSA
    add y, FLOAT_MANTISSA + FLOAT_MANTISSA_WORDS -1
    
    set x, 0                        ; current word number
    set [c], 1                        ; set sentinel
:float_div_check_subtract
    set i, [z-2]                    ; i: struct handle *divident
    set i, [i]                        ; i: struct float *divident
    add i, FLOAT_MANTISSA           ; i: divident.mantissa.msw *
    
    set a, i
    add a, FLOAT_MANTISSA_WORDS - 1      ; a: divident.mantissa.lsw *
    
    set j, [z+10]                    ; struct handle *divisor
    set j, [j]                        ; struct float *divisor
    add j, FLOAT_MANTISSA           ; j: divisor.mantissa.msw

    set x, TRUE
    
:float_div_check_subtract_loop        ; im sooo proud of this loop ;-)
    ife [i], [j]
        ifl i, a
            sti pc, float_div_check_subtract_loop
    
    ifl [i], [j]
        set x, FALSE
    
:float_div_next_bit
    shl [c], 1
    bor [c], x
    
    ife 0, ex                        ; no sentinel out
        set pc, float_div_no_word

    add c, 1
    ifg c, y                        ; all words completed?
        set pc, float_div_normalize ; exit

    set [c], 1                        ; restrart sentinel

:float_div_no_word
    ife x, FALSE                    ; skip to shift if subtract is not possible
        set pc, float_div_shift

:float_div_subtract
    set i, [z-2]                    ; i: struct handle *divident
    set i, [i]                        ; i: struct float *divident

    set a, i
    add a, FLOAT_MANTISSA           ; a: divident.mantissa.msw

    add i, FLOAT_MANTISSA_WORDS + 1      ; i: divident.mantissa.lsw

    set j, [z+10]                    ; j: struct handle *divisor
    set j, [j]                        ; j: struct float *divisor
    add j, FLOAT_MANTISSA_WORDS + 1      ; j: divisor.mantissa.lsw

    set x, 0                        ; initialize carry
:float_div_subtract_loop
    sub [i], x
    set x, 0
    ifn ex, 0
        set x, 1

    sub [i], [j]
    ifn ex, 0
        set x, 1
    
    ifg i, a
        std pc, float_div_subtract_loop    

:float_div_shift
    set i, [z-2]                    ; i: struct handle *divident
    set i, [i]                        ; i: struct float *divident

    set a, i
    add a, FLOAT_MANTISSA           ; a: divident.mantissa.msw

    add i, FLOAT_MANTISSA_WORDS + 1      ; i: divident.mantissa.lsw
    set x, 0

:float_div_shift_loop
    shl [i], 1
    bor [i], x
    set x, ex

    ifg i, a
        std pc, float_div_shift_loop

    ife x, 1
        set pc, float_div_next_bit

    ifb [i], 0x8000
        set pc, float_div_check_subtract

    set pc, float_div_next_bit
    
:float_div_normalize
    set a, [z-1]            ; struct handle *quotient
    set b, [a]                ; struct float *quotient
    set c, b
    add c, FLOAT_MANTISSA    ; quotient.msw
    set i, c                ; quotient.msw

:float_div_normalize_loop
    ifb [c], 0x8000
        set pc, float_postamble

    ife [b + FLOAT_EXPONENT], 0
        set pc, float_postamble_zero

    add i, FLOAT_MANTISSA_WORDS - 1    ; quotient.lsw
    set x, 0

:float_div_normalize_shift_loop
    shl [i], 1
    bor [i], x
    set x, ex

    ifg i, c
        std pc, float_div_normalize_shift_loop

    sub [b + FLOAT_EXPONENT], 1

    set pc, float_div_normalize_loop

;----------------------------------------------------------------
; struct handle *float_negate(struct handle *f)
;----------------------------------------------------------------
:float_negate
    set push, 1
    set push, 0
    jsr preamble
    
:float_negate_abs_merge
    set push, [z+10]
    jsr float_clone

    ; negate
    set y, [x]
    shl [y + FLOAT_CATEGORY], 8
    bor [y + FLOAT_CATEGORY], ex
    
    set pc, postamble

;----------------------------------------------------------------
; struct handle *float_abs(struct handle *f)
;----------------------------------------------------------------
:float_abs
    set push, 1
    set push, 0
    jsr preamble
    
    ; return if positive or nan
    set x, [z+10]
    set y, [x]
    ifc [y + FLOAT_CATEGORY], FLOAT_MASK_NEGATIVE
        set pc, postamble

    set pc, float_negate_abs_merge

;----------------------------------------------------------------
; struct handle *float_from_int(struct handle *int)
;----------------------------------------------------------------
:float_from_int
    set push, 1
    set push, 2
    jsr preamble

    ; postamble if int is 0
    set a, [z+10]
    set a, [a]

    ife [a], 1
        ife [a+1], 0
            set pc, float_postamble_pzero

    ; reserve space for new float
    set push, SIZEOF_FLOAT
    set push, TYPE_FLOAT
    jsr alloc
    set [z-1], x

    ; abs
    set push, [z+10]
    jsr int_abs
    set [z-2], x

    set y, [z-1]        ; struct handle *float
    set y, [y]            ; struct float *

    ; set sign
    set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_PNUM
    ifn [z+10], x
        set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NNUM

    ; z-2 is a positive number
    ; calculate exp before normalization
    set a, [x]    ; struct int *
    set a, [a]    ; int size
    shl a, 4    ; x16
    add a, 0x7fff
        
    ; get amount of bit shifting for normalization
    set x, [x]        ; struct int *
    set x, [x+1]     ; msw
    jsr float_msb
    set c, x

    ; calculate final exp
    sub a, x
    set [y + FLOAT_EXPONENT], a

    set i, [z-2]    ; struct handle *int
    set i, [i]        ; struct int *
    set a, i
    add i, 1        ; msw
    add a, [a]        ; lsw

    add y, FLOAT_MANTISSA        ; msw
    set j, y                    ; msw
    set b, y
    add b, FLOAT_MANTISSA_WORDS - 1    ; lsw

:float_from_int_loop
    set [j], [i]                ; copy word from int to float
    ifg i, a                    ; if int ptr is past lsw
        set [j], 0                ; -> use zero instead
    shl [j], c                    ; shift this word
    ifg j, y                    ; bor in the overflow unless we are already in msw
        bor [j-1], ex
    ifl j, b
        sti pc, float_from_int_loop

    ifl i, a
        set pc, float_from_int_tail

    set pc, float_postamble

:float_from_int_tail            ; needed if int.len > float.mantissa.len
    set a, [i+1]
    shl a, c
    bor [j], ex

    set pc, float_postamble

;----------------------------------------------------------------
; struct handle *float_to_int(struct handle *f)
;----------------------------------------------------------------
:float_to_int
    set push, 1
    set push, 1
    jsr preamble

    set y, [z+10]                ; struct handle *float
    set y, [y]                    ; struct float *

    ifb [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN + FLOAT_CATEGORY_PINF + FLOAT_CATEGORY_NINF
        jsr recover                ; nan or inf cannot be converted into int

    set x, INT_0
    ifb [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
        set pc, postamble        ; -0 is just 0

    set a, [y + FLOAT_EXPONENT]    ; a = float.exp
    ifg 0x8000, a                ; if float < 1
        set pc, postamble        ;   return 0

    sub a, 0x8000
    shr a, 4                    ; div a, 16
    add a, 1                    ; a = number of words required by int representation

    set b, a                    ; b = amount of bit shifting required
    shl b, 4                    ; mul a, 16
    add b, 0x7fff
    sub b, [y + FLOAT_EXPONENT]    ; shift amount

    ; allocate space for result int
    set push, a
    set push, TYPE_INT
    jsr array_create
    set [z-1], x

    set i, [z+10]               ; struct handle *float
    set i, [i]                  ; struct float *
    add i, FLOAT_MANTISSA       ; float.mantissa.msw
    set c, i                    ; float.mantissa.msw
    add c, FLOAT_MANTISSA_WORDS - 1  ; float.mantissa.lsw

    set j, [x]                  ; struct int *
    set [j], a                  ; set sizeof this int
    add a, j                    ; int.lsw
    add j, 1                    ; int.msw
    set y, 0

:float_to_int_loop
    set [j], [i]
    shr [j], b
    bor [j], y
    set y, ex

    ifl i, c
        ifl j, a
            sti pc, float_to_int_loop
    
    set y, [z+10]
    set y, [y]
    ifc FLOAT_MASK_NEGATIVE, [y + FLOAT_CATEGORY]
        set pc, postamble
        
    set push, x
    jsr int_negate
    
    set pc, postamble

;----------------------------------------------------------------
; uint float_to_uint(struct handle *float)
;----------------------------------------------------------------
:float_to_uint
    set push, 1
    set push, 1
    jsr preamble

    set push, [z+10]
    jsr float_to_int
    set [z-1], x
    
    set push, x
    jsr int_to_int16    ;int_to_uint
    
    set pc, postamble

;----------------------------------------------------------------
; struct handle *float_from_uint(uint i)
;----------------------------------------------------------------
:float_from_uint
    set push, 1
    set push, 1
    jsr preamble
    
    set push, [z+10]
    jsr uint16_to_int    ;int_from_uint
    set [z-1], x
    
    set push, [z-1]
    jsr float_from_int
    
    set pc, postamble

;----------------------------------------------------------------
; struct handle *float_from_str(struct handle *str)
;----------------------------------------------------------------
#define FP_STATE_START            1
#define FP_STATE_SIGN            2
#define FP_STATE_DIGIT_WHOLE    4
#define FP_STATE_DECIMAL_POINT    8
#define FP_STATE_DIGIT_DECIMAL    16
#define FP_STATE_E                32
#define FP_STATE_EXPONENT_SIGN    64
#define FP_STATE_EXPONENT_DIGIT    128

#define FPV_EXPONENT_NEGATIVE    -2
#define FPV_EXPONENT            -3
#define FPV_EXPONENT_MODIFIER    -4
#define FPV_STATE                -5

:float_from_str
    set push, 1            ; sizeof(args)
    set push, 1            ; sizeof(refs)
    jsr preamble

    set a, [z+10]        ; struct handle *str

    ;---------------------------------------
    ; handle nan and infinities
    ;---------------------------------------
    set b, [a]            ; struct string *
    set c, [b]            ; str.len
    
    ifg c, 2
        ife [b+1], 'i'
            ife [b+2], 'n'
                ife [b+3], 'f'
                    set pc, float_postamble_pinf

    ifg c, 2
        ife [b+1], 'n'
            ife [b+2], 'a'
                ife [b+3], 'n'
                    set pc, float_postamble_nan

    ifg c, 3
        ife [b+1], '-'
            ife [b+2], 'i'
                ife [b+3], 'n'
                    ife [b+4], 'f'
                        set pc, float_postamble_ninf                

    ifg c, 3
        ife [b+1], '+'
            ife [b+2], 'i'
                ife [b+3], 'n'
                    ife [b+4], 'f'
                        set pc, float_postamble_pinf

    ;---------------------------------------
    ; handle numbers
    ;---------------------------------------
    set [z-1], [FLOAT_PZERO]

    set push, FALSE                ; FPV_EXPONENT_NEGATIVE
    set push, 0                    ; FPV_EXPONENT
    set push, 0                    ; FPV_EXPONENT_MODIFIER
    set push, FP_STATE_START    ; FPV_STATE

    set b, 0                    ; index in str

:ffs_loop
    jsr array__get
    add b, 1
    set c, x

    ife c, '+'
        set pc, ffs_plus
    ife c, '-'
        set pc, ffs_minus
    ife c, 'e'
        set pc, ffs_exponent
    ife c, 'E'
        set pc, ffs_exponent
    ife c, '.'
        set pc, ffs_decimal_point

    ifg c, '9'                        ; not a number?
        set pc, ffs_end
    ifl c, '0'                        ; not a number?
        set pc, ffs_end

    sub c, '0'                        ; convert char to int

    ifb [z + FPV_STATE], FP_STATE_E + FP_STATE_EXPONENT_SIGN
        set pc, ffs_exponent_number
    ifb [z + FPV_STATE], FP_STATE_DIGIT_DECIMAL + FP_STATE_DECIMAL_POINT    ; if in fraction part
        set pc, ffs_fraction
    ifb [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE    ; if in whole number part
        set pc, ffs_whole_number

    set pc, ffs_end                ; wrong state for a number

:ffs_fraction
    ; parse digit to fraction
    set [z + FPV_STATE], FP_STATE_DIGIT_DECIMAL                        ; set state
    
;    ife [z + FPV_NUM_SIGNIFICANTS], 5        ; ignore non-significant decimals 
;        set pc, ffs_loop
    
    sub [z + FPV_EXPONENT_MODIFIER], 1
    set pc, ffs_add_significant

:ffs_whole_number
    set [z + FPV_STATE], FP_STATE_DIGIT_WHOLE                            ; set state

    ; ignore leading zeros
;    ife c, 0                                    ; curchar = '0'
;        ife [z + FPV_NUM_SIGNIFICANTS], 0
;            set pc, ffs_loop

;    ife [z + FPV_NUM_SIGNIFICANTS], 5
;        set pc, ffs_significant_full

:ffs_add_significant
    set push, [z-1]
    set push, [FLOAT_10]
    jsr float_mul
    set [z-1], x

    set push, [z-1]
    set push, [FLOAT_0 + c]
    jsr float_add
    set [z-1], x

    set pc, ffs_loop

:ffs_exponent_number
    set [z + FPV_STATE], FP_STATE_EXPONENT_DIGIT    ; set state

    mul [z + FPV_EXPONENT], 10
    ifn ex, 0
        set pc, ffs_overflow
        
    add [z + FPV_EXPONENT], c
    ifn ex, 0
        set pc, ffs_overflow

    set pc, ffs_loop

:ffs_overflow
    ife [z + FPV_EXPONENT_NEGATIVE], TRUE
        set pc, float_postamble_zero
    set pc, float_postamble_inf

:ffs_minus
    ifb [z + FPV_STATE], FP_STATE_START
        set pc, ffs_mantissa_minus
    ifb [z + FPV_STATE], FP_STATE_E
        set pc, ffs_exponent_minus
    set pc, ffs_end
:ffs_mantissa_minus
    ; handle leading minus
    set [z + FPV_STATE], FP_STATE_SIGN
    
    set push, [z-1]
    jsr float_negate
    set [z-1], x

    set pc, ffs_loop
:ffs_exponent_minus
    set [z + FPV_STATE], FP_STATE_EXPONENT_SIGN
    set [z + FPV_EXPONENT_NEGATIVE], TRUE
    set pc, ffs_loop
    
:ffs_plus
    ifb [z + FPV_STATE], FP_STATE_START
        set [z + FPV_STATE], FP_STATE_SIGN
    ifb [z + FPV_STATE], FP_STATE_E
        set [z + FPV_STATE], FP_STATE_EXPONENT_SIGN
    set pc, ffs_end
    
:ffs_decimal_point
    ifc [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE
        set pc, ffs_end

    set [z + FPV_STATE], FP_STATE_DECIMAL_POINT
    set pc, ffs_loop
    
:ffs_exponent
    ifc [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE + FP_STATE_DIGIT_DECIMAL
        set pc, ffs_end
    set [z + FPV_STATE], FP_STATE_E
    set pc, ffs_loop

:ffs_end
    ifb [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_E + FP_STATE_EXPONENT_SIGN
        jsr recover

    set ex, 0
    ife [z + FPV_EXPONENT_NEGATIVE], FALSE
        add [z + FPV_EXPONENT], 0x8000

    ifn ex, 0
        set pc, ffs_overflow

    add [z + FPV_EXPONENT], [z + FPV_EXPONENT_MODIFIER]
    ifb [z + FPV_EXPONENT_MODIFIER], 0x8000
        ife ex, 0
            set pc, ffs_overflow
    ifc [z + FPV_EXPONENT_MODIFIER], 0x8000
        ifn ex, 0
            set pc, ffs_overflow
    
    set a, float_mul
    set b, -1
    ifg [z + FPV_EXPONENT], 0x8000
        set pc, ffs_scale_loop
        
    set a, float_div
    set b, 1

:ffs_scale_loop
    ife [z + FPV_EXPONENT], 0x8000
        set pc, float_postamble

    set push, [z-1]
    set push, [FLOAT_10]
    jsr a
    set [z-1], x

    add [z + FPV_EXPONENT], b
    set pc, ffs_scale_loop

;----------------------------------------------------------------
; struct handle *float_to_str(struct handle *f)
;----------------------------------------------------------------
:float_to_str
    set push, 1            ; number of arguments
    set push, 2            ; amount of local variable space
    jsr preamble

    set i, [z+10]
    set i, [i]

    set x, 0
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
        set x, STR_NAN
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_PINF
        set x, STR_PINF
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NINF
        set x, STR_NINF
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NZERO
        set x, STR_NZERO
    ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_PZERO
        set x, STR_PZERO
    ifn x, 0
        set pc, postamble

    set push, 13
    set push, TYPE_STR
    jsr alloc
    set [z-1], x

    set push, [z+10]
    jsr float_abs
    set [z-2], x
    
    set a, 1        ; a: magnitude
    set b, 0        ; b: significants
    
    ife [z+10], [z-2]
        set pc, fts_scale_down

    set push, [z-1]
    set push, '-'
    jsr array__append
    
:fts_scale_down
    set push, [z-2]
    set push, [FLOAT_10]
    jsr float_cmp

    ife x, -1
        set pc, fts_print

    set push, [z-2]
    set push, [FLOAT_10]
    jsr float_div
    set [z-2], x
    
    add a, 1
    set pc, fts_scale_down

:fts_print
    set push, [z-2]
    jsr float_to_uint
    set c, x
    add x, '0'            ; change number to character

    set push, [z-1]        ; add character to string
    set push, x
    jsr array__append

    set push, [z-2]
    set push, [FLOAT_0 + c]
    jsr float_sub
    set [z-2], x

;    ife [MASK+i], MASK_ZERO
;        set pc, ftoa_fill_with_zero

    bor c, b
    ife c, 0
        set pc, fts_scale_up

    add b, 1
    ife b, 9
        set pc, fts_fill_with_zero

:fts_scale_up
    set push, [z-2]
    set push, [FLOAT_10]
    jsr float_mul
    set [z-2], x
    
    sub a, 1
    ifn a, 0
        set pc, fts_print

    set push, [z-1]        ; add character to string
    set push, '.'
    jsr array__append
    
    set pc, fts_print

:fts_fill_with_zero
    sub a, 1
    ife a, 0
        set pc, fts_finish
    ifb a, 0x8000
        set pc, fts_finish
        
    set push, [z-1]        ; add character to string
    set push, '0'
    jsr array__append
    
    set pc, fts_fill_with_zero

:fts_finish
    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
; HELPER SUBROUTINES
;----------------------------------------------------------------

;----------------------------------------------------------------
:float_postamble
; copy float from stack to heap and return from subroutine
;----------------------------------------------------------------
    set x, [z-1]    
    set pc, postamble

;----------------------------------------------------------------
:float_postamble_zero
;----------------------------------------------------------------
    set y, [z-1]
    set y, [y]
    
    set x, [FLOAT_PZERO]
    ifb [y + FLOAT_CATEGORY], FLOAT_MASK_NEGATIVE
        set x, [FLOAT_NZERO]

    set pc, postamble

;----------------------------------------------------------------
:float_postamble_inf
;----------------------------------------------------------------
    set y, [z-1]
    set y, [y]
    
    set x, [FLOAT_PINF]
    ifb [y + FLOAT_CATEGORY], FLOAT_MASK_NEGATIVE
        set x, [FLOAT_NINF]

    set pc, postamble

;----------------------------------------------------------------
:float_postamble_nzero
;----------------------------------------------------------------
    set x, [FLOAT_NZERO]
    set pc, postamble

;----------------------------------------------------------------
:float_postamble_pzero
;----------------------------------------------------------------
    set x, [FLOAT_PZERO]
    set pc, postamble

;----------------------------------------------------------------
:float_postamble_pinf
;----------------------------------------------------------------
    set x, [FLOAT_PINF]
    set pc, postamble

;----------------------------------------------------------------
:float_postamble_ninf
;----------------------------------------------------------------
    set x, [FLOAT_NINF]
    set pc, postamble

;----------------------------------------------------------------
:float_postamble_nan
;----------------------------------------------------------------
    set x, [FLOAT_NAN]
    set pc, postamble
    
;----------------------------------------------------------------
; struct handle *float_normalize(struct handle *dnf)
;----------------------------------------------------------------
:float_normalize
    set push, 1
    set push, 0
    jsr preamble

    set a, [z+10]                ; struct handle *
    set a, [a]                    ; struct float *

    set b, a                    ; struct float *
    add b, FLOAT_MANTISSA        ; float.mantissa.msw

    set c, b
    add c, FLOAT_MANTISSA_WORDS - 1    ; float.mantissa.lsw
    
    set i, b                    ; float.mantissa.msw

; start from msw and search for 1st non-zero word
:float_normalize_search_word
    ; exit loop if non-zero found
    ifn [i], 0
        set pc, float_normalize_found_word

    ; for each zero word, add (or sub?) exponent by 16
    sub [a + FLOAT_EXPONENT], 16

    ; continue loop if not yet lsw    
    ifl i, c
        sti pc, float_normalize_search_word

    ; return zero
    set pc, float_postamble_zero

:float_normalize_found_word
    set j, b                    ; float.mantissa.msw
    set x, 0
    set y, [i]                    ; value of 1st non-zero word

; calclate how many bits need to be shifted until msb is 1
:float_normalize_search_bit
    ifb y, 0x8000
        set pc, float_normalize_shift
        
    shl y, 1
    add x, 1
    
    set pc, float_normalize_search_bit

; the real work, copy and shift
; facts:
;  - j points to msw
;  - i points to 1st non-zero word
;  - x is the amount of bit shifting
;  - b points to msw
;  - c points to lsw
;  - we know this is not zero
:float_normalize_shift
    ; copy from i to j
    set [j], [i]
    
    ; if i is past lsw, overwrite j with 0
    ifg i, c
        set [j], 0

    ; do the bit shifting
    shl [j], x
    
    ; if j is past msw, merge outshifted bits to previous word
    ifg j, b
        bor [j-1], ex
    
    ifl j, c
        sti pc, float_normalize_shift

    sub [a + FLOAT_EXPONENT], x
    set x, [z+10]
    set pc, postamble

;----------------------------------------------------------------
:float_msb
; fastcall
;  x: number
; return
;  x: msb distance from bit 15
;----------------------------------------------------------------
    ifn x, 0
        set pc, float_msb_shift
    set x, 16
    set pc, pop

:float_msb_shift
    set push, x
    sub x, x

:float_msb_loop
    shl [sp], 1
    ifn ex, 0
        set pc, float_msb_exit
    add x, 1
    set pc, float_msb_loop    

:float_msb_exit
    add sp, 1
    
    set pc, pop

;----------------------------------------------------------------
; uint float_to_uint(struct handle *float)
;----------------------------------------------------------------
:float_random
    set push, 2
    set push, 2
    jsr preamble
    
    set push, SIZEOF_FLOAT
    set push, TYPE_FLOAT
    jsr alloc
    set [z-1], x

    set c, [x]
    add c, FLOAT_MANTISSA + FLOAT_MANTISSA_WORDS

    set i, [x]
    sti [i], FLOAT_CATEGORY_PNUM
    sti [i], 0x8000

:float_random_loop
    jsr int_rnd_lfsr
    sti [i], x
    ifl i, c
        set pc, float_random_loop
    
    bor [c - FLOAT_MANTISSA_WORDS], 0x8000
    
    ; transpose 1.0-2.0 to 0.0-1.0    
    set push, [z-1]
    set push, [FLOAT_1]
    jsr float_sub
    set [z-1], x

    ; scaling factor
    set push, [z+10]
    set push, [z+11]
    jsr float_sub
    set [z-2], x

    ; scale
    set push, [z-1]
    set push, [z-2]
    jsr float_mul
    set [z-1], x

    ; transpose
    set push, [z-1]
    set push, [z+11]
    jsr float_add

    set pc, postamble

;----------------------------------------------------------------
; uint float_pow(struct handle *float, struct handle *int)
;----------------------------------------------------------------
:float_pow
    set push, 2
    set push, 2
    jsr preamble

    set a, TRUE        ; positive

    set push, [z+10]
    jsr int_to_int16
    set c, x

    set x, [FLOAT_1]
    ife c, 0
        set pc, postamble

    ifc c, 0x8000
        set pc, float_pow_calc

    xor c, 0xffff
    add c, 1
    set a, FALSE

:float_pow_calc
    set [z-1], [z+11]             ; p
    set [z-2], [FLOAT_1]        ; r
    
:float_pow_loop
    ife c, 0
        set pc, float_pow_break

    ifc c, 1
        set pc, float_pow_skip
        
    set push, [z-2]
    set push, [z-1]
    jsr float_mul
    set [z-2], x
    
:float_pow_skip
    set push, [z-1]
    set push, [z-1]
    jsr float_mul
    set [z-1], x

    div c, 2
    set pc, float_pow_loop

:float_pow_break
    set x, [z-2]

    ife a, TRUE
        set pc, postamble    

    set push, [FLOAT_1]
    set push, x
    jsr float_div

    set pc, postamble    
