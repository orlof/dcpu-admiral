;----------------------------------------------------------------
:parser_stmt
; main method to parse anything
;----------------------------------------------------------------
    set push, 0
    set push, 4
    jsr preamble

    set y, [lexer_token]
    ifn [y + PROTOTYPE_STD], recover
        set pc, [y + PROTOTYPE_STD]

    jsr [y + PROTOTYPE_STD]
    #doc Statement cannot start with given token

;----------------------------------------------------------------
:parser_simple_stmt
; e.g. print hi is simple stmt
;   if true: print "Hi"
;----------------------------------------------------------------
    set push, 0
    set push, 4
    jsr preamble

    ; compound stmts are not allowed here
    ;   if true: if true: print "Hi"
    ; that would make parsing more complex
    set c, [lexer_token]
    ife c, token_while
        jsr recover
        #doc "while" was used in place of simple statement
    ife c, token_if
        jsr recover
        #doc "if" was used in place of simple statement
    ife c, token_for
        jsr recover
        #doc "for" was used in place of simple statement

    set y, [lexer_token]
    set pc, [y + PROTOTYPE_STD]

;----------------------------------------------------------------
:std_newline
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next

;----------------------------------------------------------------
:std_eof
; return struct handle *none
;----------------------------------------------------------------
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_indent
:std_dedent
; These should never occur outside compund statements
;----------------------------------------------------------------
    jsr recover
    #doc Illegal indent change error

;----------------------------------------------------------------
:std_cls
; clear lem
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next        ; skip 'cls'

    jsr [screen_mode]

    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_help
;----------------------------------------------------------------
    jsr lexer_next        ; skip 'help'

    set push, STR_HELP
    jsr print

    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_reset
; restart admiral "sys 64738"
;----------------------------------------------------------------
    jsr hires__finish
    set pc, interpreter_main

;----------------------------------------------------------------
:std_run
;----------------------------------------------------------------
    jsr lexer_next        ; skip 'run'

    ; run autoexec if there is no arguments
    ife [lexer_token], token_newline
        set pc, std_run_autoexec
    ife [lexer_token], token_eof
        set pc, std_run_autoexec

    ; filename is the 1st argument
    set push, 0
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    ; filename is required to be str
    ifc [x + HANDLE_TYPE], TYPE_STR
        jsr recover
        #doc File name must be a string error

    set pc, std_run_load

:std_run_autoexec
    ; use default filename
    set [z-1], STR_AUTOEXEC

:std_run_load
    ; load file
    set push, [z-1]
    jsr floppy__file__read
    set [z-1], x

    ; if it was not str or dict -> error
    ifc [x + HANDLE_TYPE], TYPE_GROUP_RUNNABLE
        jsr recover
        #doc Illegal content type error, only string and dict are runnable

    ; function scope
    set push, 10
    set push, TYPE_DICT
    jsr alloc
    set [z-2], x

    ; add global scope to function scope
    set push, x
    set push, STR_EX
    set push, [global_scope]
    jsr dict__set

    ; create tuple for arguments
    set push, 5
    set push, TYPE_TUPLE
    jsr alloc
    set [z-4], x

    ; add argument tuple to function scope
    set push, [z-2]
    set push, STR_ARGV
    set push, x
    jsr dict__set

    ; add 'me' if loaded object was dict
    set x, [z-1]
    ifb [x + HANDLE_TYPE], TYPE_STR
        set pc, std_run_args

    ; add 'me' to function scope
    set push, [z-2]
    set push, STR_ME
    set push, x
    jsr dict__set

:std_run_args
    ; exit arg-loop if end of line
    ife [lexer_token], token_newline
        set pc, std_run_prepare
    ife [lexer_token], token_eof
        set pc, std_run_prepare

    ; parse next argument
    set push, 0
    jsr expression
    set [z-3], x

    ; evaluate argument
    set push, x
    jsr eval
    set [z-3], x

    set push, [z-4]
    set push, [z-3]
    jsr array__append

    set pc, std_run_args

:std_run_prepare
    set push, [current_scope]
    set [current_scope], [z-2]

    jsr lexer_store

    set x, [z-1]
    ifb [x + HANDLE_TYPE], TYPE_STR
        set pc, std_run_init_lexer

    set push, [z-1]
    set push, STR_MAIN
    jsr dict_get

    ife x, 0
        jsr recover
        #doc Missing main function

    ifc [x + HANDLE_TYPE], TYPE_STR
        jsr recover
        #doc main is not callable (string)

:std_run_init_lexer
    jsr lexer_init
    set pc, led_lparen_call


;----------------------------------------------------------------
:std_out
; return struct handle *none
;----------------------------------------------------------------
    set a, FALSE
    set pc, std_print_merge

;----------------------------------------------------------------
:std_print
; return struct handle *none
;----------------------------------------------------------------
    set a, TRUE

:std_print_merge
    jsr lexer_next        ; skip 'print'

:std_print_loop
    ife [lexer_token], token_newline
        set pc, std_print_break_newline
    ife [lexer_token], token_eof
        set pc, std_print_break_eof

    set push, 0
    jsr expression
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
        set pc, std_print_array

    set push, x
    jsr eval
    set [z-1], x

    set push, x
    jsr print

    set pc, std_print_loop

:std_print_array
    set push, x
    jsr eval
    set [z-1], x

    set push, x

    set push, std_print_iterator
    jsr array_map

    set pc, std_print_loop

:std_print_iterator
    set push, c
    set push, [sp+2]
    jsr print

    set c, ' '
    jsr screen_add_char

    set c, pop
    set [sp], pop
    set pc, pop

:std_print_break_newline
    set push, token_newline
    jsr lexer_advance

:std_print_break_eof
    set c, 10
    ife a, TRUE
        jsr screen_add_char

    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_raise
;----------------------------------------------------------------
    ife [try_fp], 0
        jsr recover
        #doc Unhandled exception error

    jsr lexer_next        ; skip raise

    set x, NONE
    ife [lexer_token], token_newline
        set pc, std_raise_except
    ife [lexer_token], token_eof
        set pc, std_raise_except

    set push, 0
    jsr expression

:std_raise_except
    set z, [try_fp]
    set sp, [try_sp]
    set [try_fp], pop
    set [try_sp], pop

    set [z-1], x
    jsr lexer_restore
    jsr parser_skip_suite

    set push, token_except          ; verify except
    jsr lexer_advance

    ife [lexer_token], token_colon
        set pc, std_raise_finish

    ; get the testlist (left side)
    set push, 0x0000
    jsr testlist
    set [z-2], x

    set push, x
    set push, [z-1]
    jsr assign

:std_raise_finish
    set push, token_colon           ; verify colon
    jsr lexer_advance

    jsr parser_suite                ; process except block

    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, postamble

    set x, VOID
    set pc, postamble


;----------------------------------------------------------------
:std_exit
;----------------------------------------------------------------
    jsr lexer_next        ; skip exit

    set z, [recovery_fp]
    set sp, [recovery_sp]

    set [current_scope], [global_scope]

    set pc, interpreter_loop

;----------------------------------------------------------------
:std_return
;----------------------------------------------------------------
    jsr lexer_next        ; skip return

    set push, SIZEOF_CONTROL            ; create struct control
    set push, TYPE_CONTROL
    jsr array_create
    set [z-1], x

    set a, [x]
    set [a + CONTROL_SIGNAL], CONTROL_SIGNAL_RETURN  ; set control type
    set [a + CONTROL_VALUE], NONE                    ; default: no return value

    ife [lexer_token], token_newline
        set pc, std_return_finish
    ife [lexer_token], token_eof
        set pc, std_return_finish

    set push, 0
    jsr expression

    set a, [z-1]
    set a, [a]
    set [a + CONTROL_VALUE], x

:std_return_finish
    ; keeping lexer up to date is not needed after return
    ; set push, token_newline
    ; jsr lexer_advance

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
:std_break
;----------------------------------------------------------------
    set b, CONTROL_SIGNAL_BREAK            ; store token for control signal
    set pc, std_continue_and_break

;----------------------------------------------------------------
:std_continue
;----------------------------------------------------------------
    set b, CONTROL_SIGNAL_CONTINUE            ; store token for control signal

:std_continue_and_break
    jsr lexer_next                    ; advance 'break' or 'continue'

    ifn [lexer_token], token_newline
        ifn [lexer_token], token_eof
            jsr recover
            #doc break and continue must end line error

    jsr lexer_next                    ; advance newline or eof

    set push, SIZEOF_CONTROL        ; create struct control
    set push, TYPE_CONTROL
    jsr array_create

    set a, [x]
    set [a + CONTROL_SIGNAL], b     ; set control signal
    set [a + CONTROL_VALUE], VOID    ; default: no return value
    set pc, postamble

;----------------------------------------------------------------
:std_pass
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next

    ifn [lexer_token], token_newline
        ifn [lexer_token], token_eof
            jsr recover
            #doc pass must end line error

    set x, VOID
        set pc, postamble

;----------------------------------------------------------------
:std_for
; for x in list:
;  print x
; return VOID
; TODO 'else'
; Comments:
; Python grammar uses valid operator 'in' as for loop
; separator. there is no way for parser to detect between expression
; operator and for separator.
;----------------------------------------------------------------
    jsr lexer_next                ; advance 'for'

    ; get the testlist (left side)
    set push, 0x0000
    jsr testlist
    set [z-3], x

    set push, token_in    ; verify 'in'
    jsr lexer_advance

    ; get the exprlist (right side)
    set push, 0x0000
    jsr expression
    set [z-4], x

    set push, x
    jsr eval
    set [z-4], x

    set push, token_colon        ; verify colon
    jsr lexer_advance

    jsr lexer_store                ; store lexer position

    set i, 0

:std_for_loop
    set a, [z-3]   ; struct handle *left
    set b, [z-4]   ; struct handle *right

    set c, [b]        ; struct data *right
    ife i, [c]        ; i == rightLen -> done
        set pc, std_for_finish

    add c, i        ; c+1 = points to current item
    ifb [b + HANDLE_TYPE], TYPE_STR
        set pc, std_for_loop_string

    set push, a
    set push, [c+1]
    jsr assign

:std_for_execute_suite
    jsr parser_suite
    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, std_for_control
;    ife [lexer_token], token_eof
;        set pc, std_for_eof

:std_for_control_continue
    jsr lexer_restore                ; restore lexer to loop condition
    sti pc, std_for_loop

:std_for_loop_string
    ifb [a + HANDLE_TYPE], TYPE_TUPLE
        set pc, std_for_loop_string_tuple

    set push, a
    set push, [c+1]
    jsr assign_from_string

    set pc, std_for_execute_suite

:std_for_loop_string_tuple
    set push, a
    set push, b
    jsr assign

    set pc, std_for_execute_suite

:std_for_control
    set a, [x]
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_CONTINUE
        set pc, std_for_control_continue
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_BREAK
        set pc, std_for_control_break
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_RETURN
        set pc, postamble

    jsr recover
    #doc for loop not terminated by continue, break or return -error

:std_for_control_break
    jsr lexer_restore

:std_for_finish
    jsr parser_skip_suite

:std_for_eof
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_del
;----------------------------------------------------------------
    jsr lexer_next            ; advance 'del'

:std_del_loop
    ife [lexer_token], token_newline
        set pc, std_del_break
    ife [lexer_token], token_eof
        set pc, std_del_break

    set push, 0
    jsr expression
    set [z-1], x

    set push, x
    jsr del

    set pc, std_del_loop

:std_del_break
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_try
;----------------------------------------------------------------
    jsr lexer_next                  ; advance 'try'

    set push, token_colon           ; verify colon
    jsr lexer_advance

    jsr lexer_store                 ; store lexer position

    set push, [try_sp]
    set push, [try_fp]
    set [try_sp], sp
    set [try_fp], z

    jsr parser_suite                ; process try block
    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, std_try_finish

    set push, token_except          ; verify except
    jsr lexer_advance

    set push, token_colon           ; skip test list
    jsr parser_skip_until_token

    jsr lexer_next                  ; skip colon

    jsr parser_skip_suite           ; skip except block

    set x, VOID
:std_try_finish
    set [try_fp], pop
    set [try_sp], pop

    set pc, postamble


;----------------------------------------------------------------
:std_if
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next            ; advance 'if'

    set push, 0            ; evaluate if condition
    jsr expression
    set [z-3], x

    set push, x
    jsr eval
    set [z-3], x

    set push, x
    jsr boolean
    set [z-3], x

    set push, token_colon        ; verify colon
    jsr lexer_advance

    ife [z-3], BOOL_FALSE   ; break if loop condition is false
        set pc, std_if_false

    jsr parser_suite
    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, postamble
    ife [lexer_token], token_eof
        set pc, std_if_eof

    set pc, std_if_skip

:std_if_skip_loop
    set push, token_colon
    jsr parser_skip_until_token

    jsr lexer_next            ; skip COLON

    jsr parser_skip_suite
    ife [lexer_token], token_eof
        set pc, std_if_eof

:std_if_skip
    ife [lexer_token], token_elif
        set pc, std_if_skip_loop
    ife [lexer_token], token_else
        set pc, std_if_skip_loop

    set pc, std_if_eof

:std_if_false
    jsr parser_skip_suite
    ife [lexer_token], token_elif
        set pc, std_if
    ife [lexer_token], token_else
        set pc, std_if_else

    set pc, std_if_eof

:std_if_else
    jsr lexer_next        ; skip else

    set push, token_colon
    jsr lexer_advance    ; skip COLON

    jsr parser_suite

    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, postamble

:std_if_eof
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_while
; return struct handle *none
; todo implement else
;----------------------------------------------------------------
    jsr lexer_next                ; advance 'while'

    jsr lexer_store                ; store lexer position

:std_while_loop
    set push, 0                    ; evaluate loop condition
    jsr expression
    set [z-3], x

    set push, x
    jsr boolean
    set [z-3], x

    set push, token_colon        ; verify colon
    jsr lexer_advance

    ife [z-3], BOOL_FALSE   ; break if loop condition is false
        set pc, std_while_false

    jsr parser_suite
    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, std_while_control
;    ife [lexer_token], token_eof
;        set pc, std_while_eof

:std_while_control_continue
    jsr lexer_restore                ; restore lexer to loop condition
    set pc, std_while_loop

:std_while_control
    set a, [x]
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_CONTINUE
        set pc, std_while_control_continue
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_BREAK
        set pc, std_while_control_break
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_RETURN
        set pc, postamble

    jsr recover
    #doc assertion failed, unknown control signal terminated while loop

:std_while_control_break
    jsr lexer_restore

    set push, token_colon
    jsr parser_skip_until_token

    jsr lexer_next        ; skip colon

:std_while_false
    jsr parser_skip_suite

:std_while_eof
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
; void parser_skip_until_token()
;----------------------------------------------------------------
:parser_skip_until_token
    ife [lexer_token], [sp + 1]
        set pc, parser_skip_until_token_finish
    ife [lexer_token], token_eof
        set pc, parser_skip_until_token_finish

    jsr lexer_next
    set pc, parser_skip_until_token

:parser_skip_until_token_finish
    set [sp], pop
    set pc, pop

;----------------------------------------------------------------
; void parser_skip_suite()
;----------------------------------------------------------------
:parser_skip_suite
;    set push, 0
;    set push, 0
;    jsr preamble

    ife [lexer_token], token_newline
        set pc, parser_skip_suite_block

:parser_skip_suite_simple_stmt
    set push, token_newline
    jsr parser_skip_until_token

:parser_skip_suite_simple_stmt_finish
    jsr lexer_next        ; skip newline
    set pc, pop

:parser_skip_suite_block
    jsr lexer_next        ; skip newline

    set push, token_indent    ; verify indent
    jsr lexer_advance

    set push, 1

:parser_skip_suite_block_loop
    ife [lexer_token], token_indent
        add [sp], 1
    ife [lexer_token], token_dedent
        sub [sp], 1

    jsr lexer_next

    ifn [sp], 0
        set pc, parser_skip_suite_block_loop

;    add sp, 1
    set ex, pop     ; pop value to dev/null
    set pc, pop


;----------------------------------------------------------------
; void parser_suite()
;----------------------------------------------------------------
:parser_suite
    set push, 0
    set push, 0
    jsr preamble

    ife [lexer_token], token_newline
        set pc, parser_suite_block

:parser_suite_simple_stmt
    jsr parser_simple_stmt
    set pc, postamble

:parser_suite_block
    jsr lexer_next        ; skip newline

    set push, token_indent    ; verify indent
    jsr lexer_advance

:parser_suite_block_loop
    jsr parser_stmt

    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, postamble

    ife [lexer_token], token_dedent
        set pc, parser_suite_block_break

    ife [lexer_token], token_eof
        set pc, postamble

    set pc, parser_suite_block_loop

:parser_suite_block_break
    set push, x
    jsr lexer_next    ; skip dedent
    set x, pop
    set pc, postamble

;----------------------------------------------------------------
:std_expression
;----------------------------------------------------------------
    set push, 0
    jsr expression

    set pc, postamble

;----------------------------------------------------------------
; struct handle *expression(uint16 rbp)
;----------------------------------------------------------------
:expression
    set push, 1
    set push, 1            ; struct handle *left
    jsr preamble

    set b, [z+10]        ; rbp

    set c, [lexer_token]
    jsr [c + PROTOTYPE_NUD]
    #doc Syntax error

    set [z-1], x       ; struct handle *left

:expr_loop
    set c, [lexer_token]

    ifg b, [c + PROTOTYPE_LBP]
        set pc, expr_finish
    ife b, [c + PROTOTYPE_LBP]
        set pc, expr_finish

    set push, [z-1]
    jsr [c + PROTOTYPE_LED]
:expression_callback
    set [z-1], x        ; struct handle *left

    set pc, expr_loop

:expr_finish
    set x, [z-1]       ; struct handle *left
    set pc, postamble

;----------------------------------------------------------------
; struct handle *testlist(uint16 rbp)
;----------------------------------------------------------------
:testlist
    set push, 1
    set push, 1            ; struct handle *left
    jsr preamble

    set b, [z+10]        ; rbp

    set y, 0
    ife [lexer_token], token_name
        set y, nud_name
    ife [lexer_token], token_lparen
        set y, nud_lparen

    ife y, 0
        jsr recover
        #doc Illegal list definition error

    jsr y
    set [z-1], x       ; struct handle *left

:testlist_loop
    set c, [lexer_token]

    ifg b, [c + PROTOTYPE_LBP]
        set pc, expr_finish
    ife b, [c + PROTOTYPE_LBP]
        set pc, expr_finish

    set y, 0
    ife c, token_lbrack
        set y, led_lbrack
    ife c, token_reference
        set y, led_reference
    ife c, token_comma
        set y, led_comma

    ife y, 0
        set pc, expr_finish

    set push, [z-1]
    jsr y
:testlist_callback
    set [z-1], x       ; struct handle *left

    set pc, testlist_loop

;----------------------------------------------------------------
; struct handle *nud_int()
;----------------------------------------------------------------
:nud_str
:nud_name
    jsr lexer_get_token_as_string
    set [z-1], x

    jsr lexer_next

    set x, [z-1]
    set pc, pop

:nud_hex
    set a, int_parse_hex
    set pc, nud_generic

:nud_float
    set a, float__from_str
    set pc, nud_generic

:nud_int
    set a, int_parse

:nud_generic
    jsr lexer_get_token_as_string
    set [z-1], x

    set push, x
    jsr a
    set [z-1], x

    jsr lexer_next

    set x, [z-1]
    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_none()
;----------------------------------------------------------------
:nud_none
    jsr lexer_next
    set x, NONE
    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_true()
;----------------------------------------------------------------
:nud_true
    jsr lexer_next
    set x, BOOL_TRUE
    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_false()
;----------------------------------------------------------------
:nud_false
    jsr lexer_next
    set x, BOOL_FALSE
    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_lparen()
; expression or tuple
;----------------------------------------------------------------
:nud_lparen
    set push, 0
    set push, 1
    jsr preamble

    jsr lexer_next    ; skip '('

    ife [lexer_token], token_rparen
        set pc, nud_lparen_empty

    set push, 0
    jsr expression
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
        set [x + HANDLE_TYPE], TYPE_TUPLE

    set push, token_rparen
    jsr lexer_advance

    set x, [z-1]
    set pc, postamble

:nud_lparen_empty
    jsr lexer_next    ; skip ')'

    set push, 0
    set push, TYPE_TUPLE
    jsr array_create

    set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_lbrack()
; list
;----------------------------------------------------------------
:nud_lbrack
    set push, 0
    set push, 2
    jsr preamble

    jsr lexer_next    ; skip '['

    ife [lexer_token], token_rbrack
        set pc, nud_lbrack_empty

    set push, 0
    jsr expression
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
        set pc, nud_lbrack_change_type

    set push, 5
    set push, TYPE_LIST
    jsr alloc
    set [z-2], x

    set a, [x]
    set [a], 1
    set [a+1], [z-1]
    set pc, nud_lbrack_continue

:nud_lbrack_change_type
    set [x + HANDLE_TYPE], TYPE_LIST
    set [z-2], x

:nud_lbrack_continue
    set push, token_rbrack
    jsr lexer_advance

    set x, [z-2]
    set pc, postamble

:nud_lbrack_empty
    jsr lexer_next    ; skip ']'

    set push, 5
    set push, TYPE_LIST
    jsr alloc

    set pc, postamble
;----------------------------------------------------------------
; struct handle *nud_lcurly()
; dict
;----------------------------------------------------------------
:nud_lcurly
    set push, 0
    set push, 3
    jsr preamble

    set push, 5
    set push, TYPE_DICT
    jsr alloc
    set [z-1], x

:nud_lcurly_loop
    jsr lexer_next    ; skip '{' or ','

    ife [lexer_token], token_rcurly
        set pc, nud_lcurly_finish

    ; left side (key)
    set push, 0
    jsr expression
    set [z-2], x

    set push, x
    jsr eval
    set [z-2], x

    set push, token_colon
    jsr lexer_advance        ; skip ':'

    ; right side (value)
    set push, 0x0030        ; break at comma
    jsr expression
    set [z-3], x

    set push, x
    jsr eval
    set [z-3], x

    ; kv-pair
    ; set push, 2
    ; set push, TYPE_TUPLE
    ; jsr array_create
    ; set [z-2], x

    ; set a, [x]
    ; set [a + DICT_ITEM_KEY],   [z-3]
    ; set [a + DICT_ITEM_VALUE], [z-4]

    set push, [z-1]
    set push, [z-2]
    set push, [z-3]
    jsr dict__set

    ife [lexer_token], token_comma
        set pc, nud_lcurly_loop

:nud_lcurly_finish
    set push, token_rcurly
    jsr lexer_advance

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_plus()
;----------------------------------------------------------------
:nud_plus
    jsr lexer_next

    set push, 0x0150
    jsr expression

    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_minus()
;----------------------------------------------------------------
:nud_minus
    set push, 0
    set push, 1
    jsr preamble

    jsr lexer_next

    set push, 0x0150
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    set y, 0
    ifb [x + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
        set y, int_negate
    ifb [x + HANDLE_TYPE], TYPE_FLOAT
        set y, float__negate

    ife y, 0
        jsr recover
        #doc Only number types can be used in subtract operation

    set push, x
    jsr y

    set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_tilde()
;----------------------------------------------------------------
:nud_tilde
    set push, 0
    set push, 1
    jsr preamble

    jsr lexer_next

    set push, 0x0160
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
        set pc, nud_tilde_int

    jsr recover
        #doc Only integer and boolean types can be used in negate operation

:nud_tilde_int
    set push, x
    jsr int_complement

    set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_not()
;----------------------------------------------------------------
:nud_not
    set push, 0
    set push, 1
    jsr preamble

    jsr lexer_next

    set push, 0x0055
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    set push, x
    jsr boolean
    set a, x

    set x, BOOL_FALSE
    ife a, BOOL_FALSE
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_and(struct handle *left)
;----------------------------------------------------------------
:led_and
    set push, 1
    set push, 1
    jsr preamble

    set x, [lexer_token]
    set push, [x + PROTOTYPE_LBP]        ; push for expression call

    ; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    set push, x
    jsr boolean
    set [z-1], x

    jsr lexer_next

    ; right side
    jsr expression

    ife [z-1], BOOL_FALSE
        set pc, led_and__finish

    set [z-1], x

    ; evaluate right side
    set push, x
    jsr eval
    set [z-1], x

    set push, x
    jsr boolean
    set [z-1], x

:led_and__finish
    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_or(struct handle *left)
;----------------------------------------------------------------
:led_or
    set push, 1
    set push, 2
    jsr preamble

    set x, [lexer_token]
    set push, [x + PROTOTYPE_LBP]        ; push for expression call

    ; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    set push, x
    jsr boolean
    set [z-2], x

    jsr lexer_next

    ; right side
    jsr expression

    ife [z-2], BOOL_TRUE
        set pc, led_or__finish

    set [z-2], x

    ; evaluate right side
    set push, x
    jsr eval
    set [z-1], x

:led_or__finish
    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_is(struct handle *left)
;----------------------------------------------------------------
:led_is
    set push, 1
    set push, 2
    jsr preamble

    set a, TRUE

    jsr lexer_next
    ifn [lexer_token], token_not
        set a, FALSE
    ife [lexer_token], token_not
        jsr lexer_next

    ; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    ; parse right side
    set push, 0x0070
    jsr expression
    set [z-2], x

    ; evaluate right side
    set push, [z-2]
    jsr eval
    set [z-2], x

    ife a, TRUE
        set pc, led_is_not

    set x, BOOL_FALSE
    ife [z-2], [z-1]
        set x, BOOL_TRUE

    set pc, postamble

:led_is_not
    set x, BOOL_TRUE
    ife [z-2], [z-1]
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_not(struct handle *left)
;----------------------------------------------------------------
:led_not
    set push, 1
    set push, 2
    jsr preamble

    jsr lexer_next    ; advance not

    set a, TRUE
    set pc, led_in_1

;----------------------------------------------------------------
; struct handle *led_in(struct handle *left)
;----------------------------------------------------------------
:led_in
    set push, 1
    set push, 2
    jsr preamble

    set a, FALSE

:led_in_1
    set push, token_in
    jsr lexer_advance    ; verify led

; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    ; parse right side
    set push, 0x0060
    jsr expression
    set [z-2], x

    ; evaluate right side
    set push, [z-2]
    jsr eval
    set [z-2], x

    ifb [x + HANDLE_TYPE], TYPE_STR
        set pc, led_in_string

    ifb [x + HANDLE_TYPE], TYPE_DICT
        set pc, led_in_dict

    ifb [x + HANDLE_TYPE], TYPE_TUPLE + TYPE_LIST
        set pc, led_in_list

    jsr recover
    #doc Right side of "in" is not container or string error

:led_in_string
    set push, x
    set push, [z-1]
    jsr str_search
    ife x, -1
        set pc, led_in_not_found
    set pc, led_in_found

:led_in_dict
    set push, x
    set push, [z-1]
    jsr dict_get
    ife x, 0
        set pc, led_in_not_found
    set pc, led_in_found

:led_in_list
    set push, x
    set push, [z-1]
    jsr array_find
    ife x, -1
        set pc, led_in_not_found

:led_in_found
    set x, BOOL_TRUE
    ife a, TRUE
        set x, BOOL_FALSE

    set pc, postamble

:led_in_not_found
    set x, BOOL_FALSE
    ife a, TRUE
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_less_or_equal(struct handle *left)
;----------------------------------------------------------------
:led_less_or_equal
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_TRUE
    ife a, 1
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_less(struct handle *left)
;----------------------------------------------------------------
:led_less
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_FALSE
    ife a, -1
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_greater_or_equal(struct handle *left)
;----------------------------------------------------------------
:led_greater_or_equal
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_TRUE
    ife a, -1
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_greater(struct handle *left)
;----------------------------------------------------------------
:led_greater
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_FALSE
    ife a, 1
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_not_equal(struct handle *left)
;----------------------------------------------------------------
:led_not_equal
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_FALSE
    ifn a, 0
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_equal(struct handle *left)
;----------------------------------------------------------------
:led_equal
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_FALSE
    ife a, 0
        set x, BOOL_TRUE

    set pc, postamble

:compare_operator
    jsr lexer_next

    ; right side
    set push, 0x0080
    jsr expression
    set [z-2], x

    ; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    ; evaluate right side
    set push, [z-2]
    jsr eval
    set [z-2], x

    set push, [z-1]
    set push, [z-2]
    jsr val_cmp
    set a, x

    set pc, pop

;----------------------------------------------------------------
; struct handle *led_plus(struct handle *left)
;----------------------------------------------------------------
:led_plus
    ; todo str+str, tuple+tuple, list+list, int+int, float+int, int+float, float+float
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_plus_operation

    set pc, postamble

:led_plus_operation
    jsr cast_common_number_type
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_add
    ife c, TYPE_FLOAT
        set y, float__add
    ife c, TYPE_STR
        set y, array_merge
    ife c, TYPE_LIST
        set y, array_merge
    ife c, TYPE_TUPLE
        set y, array_merge

:led_operation_tailer
    set push, a
    set push, b
    jsr y

    set pc, pop

;----------------------------------------------------------------
; struct handle *led_minus(struct handle *left)
;----------------------------------------------------------------
:led_minus
    ; todo int-int, float-int, int-float, float-float
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_minus_operation

    set pc, postamble

:led_minus_operation
    jsr cast_common_number_type
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_sub
    ife c, TYPE_FLOAT
        set y, float__sub

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_star(struct handle *left)
;----------------------------------------------------------------
:led_star
    ; todo int*int, int*float, float*int, float*float, int*str, str*int, int*tuple, tuple*int, int*list, list*int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_star_operation

    set pc, postamble

:led_star_operation
    jsr cast_common_number_type
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_mul
    ife c, TYPE_FLOAT
        set y, float__mul
    ife c, TYPE_STR + TYPE_INT
        set y, array_repeat
    ife c, TYPE_TUPLE + TYPE_INT
        set y, array_repeat
    ife c, TYPE_LIST + TYPE_INT
        set y, array_repeat

    ifc [a + HANDLE_TYPE], TYPE_INT
        set pc, led_operation_tailer

    ; swap a and b
    set ex, a
    set a, b
    set b, ex

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_power(struct handle *left)
;----------------------------------------------------------------
:led_power
    ; todo int*int, int*float, float*int, float*float
    set push, 1
    set push, 2
    jsr preamble

    jsr infixr
    jsr led_power_operation

    set pc, postamble

:led_power_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_pow

    ifb [a + HANDLE_TYPE], TYPE_FLOAT
        ifb [b + HANDLE_TYPE], TYPE_INT
            set y, float__pow

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_bitwise_or(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_or
    ; int*int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_bitwise_or_operation

    set pc, postamble

:led_bitwise_or_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_bitwise_or

    set pc, led_operation_tailer


;----------------------------------------------------------------
; struct handle *led_bitwise_xor(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_xor
    ; int*int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_bitwise_xor_operation

    set pc, postamble

:led_bitwise_xor_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_bitwise_xor

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_bitwise_and(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_and
    ; int*int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_bitwise_and_operation

    set pc, postamble

:led_bitwise_and_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_bitwise_and

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_lshift(struct handle *left)
;----------------------------------------------------------------
:led_lshift
    ; int << int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_lshift_operation

    set pc, postamble

:led_lshift_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_lshift

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_rshift(struct handle *left)
;----------------------------------------------------------------
:led_rshift
    ; int >> int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_rshift_operation

    set pc, postamble

:led_rshift_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_rshift

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_slash(struct handle *left)
;----------------------------------------------------------------
:led_slash
    ; todo int/int, int/float, float/int, float/float
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_slash_operation

    set pc, postamble

:led_slash_operation
    jsr cast_common_number_type
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_div
    ife c, TYPE_FLOAT
        set y, float__div

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_percent(struct handle *left)
;----------------------------------------------------------------
:led_percent
    ; todo int/int, int/float, float/int, float/float
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_percent_operation

    set pc, postamble

:led_percent_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_mod

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_assign(struct handle *left)
;----------------------------------------------------------------
:led_assign
    set push, 1
    set push, 1
    jsr preamble

    jsr lexer_next

    ; right side
    set push, 0x0009                     ; right binding power
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    set push, [z+10]
    set push, x
    jsr assign

    set pc, postamble

;----------------------------------------------------------------
:led_augass
;----------------------------------------------------------------
    ; we cheat here, as stack is wrongly organized
    ; z+10
    ; rts
    ; z+11
    ; we must copy rts and z11 to get proper stack bottom
    set push, [sp+2]
    set push, [sp+2]

    ; here we claim 4 parameters, to make postamble clean them all
    set push, 4
    set push, 2
    jsr preamble

    jsr infixr

    jsr [z+11]
    set [z-1], x

    set push, [z+10]
    set push, x
    jsr assign

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_augass_lshift(struct handle *left)
;----------------------------------------------------------------
:led_augass_lshift
    set push, led_lshift_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_rshift(struct handle *left)
;----------------------------------------------------------------
:led_augass_rshift
    set push, led_rshift_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_or(struct handle *left)
;----------------------------------------------------------------
:led_augass_or
    set push, led_bitwise_or_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_xor(struct handle *left)
;----------------------------------------------------------------
:led_augass_xor
    set push, led_bitwise_xor_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_and(struct handle *left)
;----------------------------------------------------------------
:led_augass_and
    set push, led_bitwise_and_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_plus(struct handle *left)
;----------------------------------------------------------------
:led_augass_plus
    set push, led_plus_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_minus(struct handle *left)
;----------------------------------------------------------------
:led_augass_minus
    set push, led_minus_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_star(struct handle *left)
;----------------------------------------------------------------
:led_augass_star
    set push, led_star_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_slash(struct handle *left)
;----------------------------------------------------------------
:led_augass_slash
    set push, led_slash_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_percent(struct handle *left)
;----------------------------------------------------------------
:led_augass_percent
    set push, led_percent_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_lparen(struct handle *left)
; function call
;----------------------------------------------------------------
:led_lparen
    set push, 1
    set push, 5
    jsr preamble

    set pc, built_in

:led_lparen_user_defined
    ; prepare scope
    set push, 10        ; create scope for function call
    set push, TYPE_DICT
    jsr alloc
    set [z-1], x

    set push, x            ; add global scope (ex)
    set push, STR_EX
    set push, [global_scope]
    jsr dict__set

    ; create tuple for arguments
    set push, 5
    set push, TYPE_TUPLE
    jsr alloc
    set [z-4], x

    ; add argument tuple to function scope
    set push, [z-1]
    set push, STR_ARGV
    set push, x
    jsr dict__set

    set a, [z+10]        ; if call is by reference, add path dict to scope (me)
    ifc [a + HANDLE_TYPE], TYPE_GROUP_SELF_AWARE
        set pc, led_lparen_args

    set a, [a]            ; a = struct reference *

    set push, [z-1]
    set push, STR_ME
    set push, [a + REFERENCE_OR_SUBSCRIPTION_ROOT]
    jsr dict__set

:led_lparen_args
    jsr lexer_next    ; skip '(' or ','

    ife [lexer_token], token_rparen
        set pc, led_lparen_prepare_call

    ; read value or name
    set push, 0x0030
    jsr expression
    set [z-2], x

    ife [lexer_token], token_assign
        ; key=value
        set pc, parse_testlist_item_assign

    ; argv[n]=value
    set push, x
    jsr eval
    set [z-2], x

    set push, [z-4]
    set push, x
    jsr array__append

    set pc, led_lparen_arg_loop_condition

:parse_testlist_item_assign
    ; f(a=1)
    ifc [x + HANDLE_TYPE], TYPE_NAME
        jsr recover
        #doc Invalid name for function call parameter error

    jsr lexer_next    ; skip '='

    ; read value
    set push, 0x0030
    jsr expression
    set [z-3], x

    set push, x
    jsr eval
    set [z-3], x

    set push, [z-1]
    set push, [z-2]
    set push, [z-3]
    jsr dict__set

:led_lparen_arg_loop_condition
    ife [lexer_token], token_comma
        set pc, led_lparen_args

:led_lparen_prepare_call
    set push, token_rparen
    jsr lexer_advance    ; skip ')'

    set push, [z+10]
    jsr eval
    set [z-2], x

    ifc [x + HANDLE_TYPE], TYPE_STR
        jsr recover
        #doc Only strings are callable error

    set push, [current_scope]
    set [current_scope], [z-1]

    jsr lexer_store

    set x, [z-2]
    jsr lexer_init

:led_lparen_call
    jsr parser_stmt
    set [z-3], x

    ifb [x+HANDLE_TYPE], TYPE_CONTROL
        set pc, led_lparen_control

    ifn [lexer_token], token_eof
        set pc, led_lparen_call

    set a, NONE

:led_lparen_finish
    jsr lexer_restore
    set [current_scope], [sp+6]
    set x, a
    set pc, postamble

:led_lparen_control
    set a, [x]
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_RETURN
        set pc, led_lparen_control_return

    jsr recover
    #doc Assertion failed: Illegal control signal in function return

:led_lparen_control_return
    set push, [a + CONTROL_VALUE]
    jsr eval
:led_lparen_control_raise
    set a, x

    set pc, led_lparen_finish

;----------------------------------------------------------------
:parse_testlist_item
;----------------------------------------------------------------
    set pc, pop

;----------------------------------------------------------------
; struct handle *led_lbrack(struct handle *left)
;----------------------------------------------------------------
:led_lbrack
    set push, 1
    set push, 3
    jsr preamble

    jsr lexer_next            ; skip '['

    ; eval left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_DICT    ; branch dict
        set pc, led_lbrack_dict

    ifc [x + HANDLE_TYPE], TYPE_STR + TYPE_TUPLE + TYPE_LIST
        jsr recover
        #doc Element subscription is available only for dict, string, tuple and list

    ; handle str, tuple, list
    ifn [lexer_token], token_colon
        set pc, led_lbrack_parse_first

    ; no slice start, assume 0
    set [z-2], INT_0
    set pc, led_lbrack_after_colon

:led_lbrack_parse_first
    ; parse slice start or index
    set push, 0
    jsr expression
    set [z-2], x

    set push, x
    jsr eval
    set [z-2], x

    ifn [lexer_token], token_colon
        set pc, led_lbrack_finish    ; no colon -> index

:led_lbrack_after_colon
    jsr lexer_next                ; skip ':'
    ; [z-2] now contains slice start
    set [z-3], [z-2]

    set push, 2
    set push, TYPE_TUPLE
    jsr array_create
    set [z-2], x

    set x, [x]
    set [x+1], [z-3]           ; slice start

    ife [lexer_token], token_rbrack
        set pc, led_lbrack_empty_after_colon

    set push, 0
    jsr expression
    set [z-3], x

    set push, x
    jsr eval
    set [z-3], x

    set a, [z-2]
    set a, [a]
    set [a+2], [z-3]        ; slice end

    set pc, led_lbrack_finish

:led_lbrack_empty_after_colon
    ; set array len to slice end
    set a, [z-1]
    set a, [a]

    set push, [a]
    jsr  uint16_to_int
    set [z-3], x

    set a, [z-2]
    set a, [a]
    set [a+2], [z-3]        ; slice end

    set pc, led_lbrack_finish

:led_lbrack_dict
    set push, 0
    jsr expression
    set [z-2], x

    set push, x
    jsr eval
    set [z-2], x

    ifc [x + HANDLE_TYPE], TYPE_STR + TYPE_INT + TYPE_BOOL + TYPE_FLOAT + TYPE_NONE
        jsr recover
        #doc dict key is not recursively immutable error

:led_lbrack_finish
    set push, token_rbrack
    jsr lexer_advance

    ; construct return value
    set push, 2
    set push, TYPE_SUBSCRIPTION
    jsr array_create
    set [z-3], x            ; result

    set a, [x]
    set [a + SUBSCRIPTION_LIST], [z-1]
    set [a + SUBSCRIPTION_INDEX], [z-2]

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_reference(struct handle *left)
; attribute reference
;----------------------------------------------------------------
:led_reference
    set push, 1
    set push, 3
    jsr preamble

    set push, 2
    set push, TYPE_REFERENCE
    jsr array_create
    set [z-1], x

    set push, [z+10]
    jsr eval

    ifc [x + HANDLE_TYPE], TYPE_GROUP_CAN_REFERENCE
        jsr recover
        #doc Illegal reference from non string, list or dict error

    set a, [z-1]
    set a, [a]
    set [a + REFERENCE_LEFT], x

    jsr lexer_next

    ifn [lexer_token], token_name
        jsr recover
        #doc Illegal reference name

    jsr lexer_get_token_as_string
;    set [x + HANDLE_TYPE], TYPE_STR

    set a, [z-1]
    set a, [a]
    set [a + REFERENCE_RIGHT], x

    jsr lexer_next

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
:infixr
    set a, [lexer_token]
    set a, [a + PROTOTYPE_LBP]        ; push for expression call
    sub a, 1
    set push, a
    set pc, infix_1

;----------------------------------------------------------------
:infix
; fastcall
; return
;   a: struct handle *left
;   b: struct handle *right
;   y: 0
;----------------------------------------------------------------
    set a, [lexer_token]
    set push, [a + PROTOTYPE_LBP]        ; push for expression call

:infix_1
    ; left
    set push, [z+10]
    jsr eval
    set [z-1], x
    set a, x

    jsr lexer_next

    ; right side
    jsr expression
    set [z-2], x

    set push, x
    jsr eval
    set [z-2], x
    set b, x

    set y, recover

    set pc, pop

;----------------------------------------------------------------
; struct handle *led_comma(struct handle *left)
; tuple
;----------------------------------------------------------------
:led_comma
    set push, 1
    set push, 2
    jsr preamble

    set a, [z+10]
    set [z-1], a
    ifb [a + HANDLE_TYPE], TYPE_TUPLE_COMMA
        set pc, led_comma_add

    set push, 5
    set push, TYPE_TUPLE_COMMA
    jsr alloc
    set [z-1], x

    set x, [x]
    set [x], 1
    set [x+1], a

:led_comma_add
    jsr lexer_next

    set a, [lexer_token]
    ifn [a + PROTOTYPE_STD], std_expression
        set pc, led_comma_end

    set push, 0x0020
    ife [z+9], expression_callback
        jsr expression
    ife [z+9], testlist_callback
        jsr testlist
    set [z-2], x

    set push, [z-1]
    set push, [z-2]
    jsr array__append

:led_comma_end
    set x, [z-1]    ; expr
    set pc, postamble
