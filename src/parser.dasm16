;----------------------------------------------------------------
:parser_stmt
; main method to parse anything
;----------------------------------------------------------------
    set push, 0
    set push, 4
    jsr preamble

    set y, [lexer_token]
    ifn [y + PROTOTYPE_STD], recover
        set pc, [y + PROTOTYPE_STD]

    jsr [y + PROTOTYPE_STD]
    #doc Statement cannot start with given token

;----------------------------------------------------------------
:parser_simple_stmt
; e.g. print hi is simple stmt
;   if true: print "Hi"
;----------------------------------------------------------------
    set push, 0
    set push, 4
    jsr preamble

    ; compound stmts are not allowed here
    ;   if true: if true: print "Hi"
    ; that would make parsing more complex
    set c, [lexer_token]
    ife c, token_while
        jsr recover
        #doc "while" was used in place of simple statement
    ife c, token_if
        jsr recover
        #doc "if" was used in place of simple statement
    ife c, token_for
        jsr recover
        #doc "for" was used in place of simple statement

    set y, [lexer_token]
    set pc, [y + PROTOTYPE_STD]

;----------------------------------------------------------------
:std_newline
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next

;----------------------------------------------------------------
:std_eof
; return struct handle *none
;----------------------------------------------------------------
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_indent
:std_dedent
; These should never occur outside compund statements
;----------------------------------------------------------------
    jsr recover
    #doc Illegal indent change error

;----------------------------------------------------------------
:std_cls
; clear lem
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next        ; skip 'cls'

    jsr screen_clear

    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_help
;----------------------------------------------------------------
    jsr lexer_next        ; skip 'help'

    set push, STR_HELP
    jsr print

    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_reset
; restart admiral "sys 64738"
;----------------------------------------------------------------
    jsr hires__finish
    set pc, interpreter_main

;----------------------------------------------------------------
:std_run
;----------------------------------------------------------------
    jsr lexer_next        ; skip 'run'

    ; run autoexec if there is no arguments
    ife [lexer_token], token_newline
        set pc, std_run_autoexec
    ife [lexer_token], token_eof
        set pc, std_run_autoexec

    ; filename is the 1st argument
    set push, 0
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    ; filename is required to be str
    ifc [x + HANDLE_TYPE], TYPE_STR
        jsr recover
        #doc File name must be a string error

    set pc, std_run_load

:std_run_autoexec
    ; use default filename
    set [z-1], STR_AUTOEXEC

:std_run_load
    ; load file
    set push, [z-1]
    jsr floppy__file__read
    set [z-1], x

    ; if it was not str or dict -> error
    ifc [x + HANDLE_TYPE], TYPE_GROUP_RUNNABLE
        jsr recover
        #doc Illegal content type error, only string and dict are runnable

    ; function scope
    set push, 10
    set push, TYPE_DICT
    jsr alloc
    set [z-2], x

    ; add global scope to function scope
    set push, x
    set push, STR_EX
    set push, [global_scope]
    jsr dict__set

    ; create tuple for arguments
    set push, 5
    set push, TYPE_TUPLE
    jsr alloc
    set [z-4], x

    ; add argument tuple to function scope
    set push, [z-2]
    set push, STR_ARGV
    set push, x
    jsr dict__set

    ; add 'me' if loaded object was dict
    set x, [z-1]
    ifb [x + HANDLE_TYPE], TYPE_STR
        set pc, std_run_args

    ; add 'me' to function scope
    set push, [z-2]
    set push, STR_ME
    set push, x
    jsr dict__set

:std_run_args
    ; exit arg-loop if end of line
    ife [lexer_token], token_newline
        set pc, std_run_prepare
    ife [lexer_token], token_eof
        set pc, std_run_prepare

    ; parse next argument
    set push, 0
    jsr expression
    set [z-3], x

    ; evaluate argument
    set push, x
    jsr eval
    set [z-3], x

    set push, [z-4]
    set push, [z-3]
    jsr array__append

    set pc, std_run_args

:std_run_prepare
    set push, [current_scope]
    set [current_scope], [z-2]

    jsr lexer_store

    set x, [z-1]
    ifb [x + HANDLE_TYPE], TYPE_STR
        set pc, std_run_init_lexer

    set push, [z-1]
    set push, STR_MAIN
    jsr dict_get

    ife x, 0
        jsr recover
        #doc Missing main function

    ifc [x + HANDLE_TYPE], TYPE_STR
        jsr recover
        #doc main is not callable (string)

:std_run_init_lexer
    jsr lexer_init
    set pc, led_lparen_call


;----------------------------------------------------------------
:std_print
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next        ; skip 'print'

:std_print_loop
    ife [lexer_token], token_newline
        set pc, std_print_break_newline
    ife [lexer_token], token_eof
        set pc, std_print_break_eof

    set push, 0
    jsr expression
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
        set pc, std_print_array

    set push, x
    jsr eval
    set [z-1], x

    set push, x
    jsr print

    set pc, std_print_loop

:std_print_array
    set push, x
    jsr eval
    set [z-1], x

    set push, x

    set push, std_print_iterator
    jsr array_map

    set pc, std_print_loop

:std_print_iterator
    set push, c
    set push, [sp+2]
    jsr print

    set c, ' '
    jsr screen_add_char

    set c, pop
    set [sp], pop
    set pc, pop

:std_print_break_newline
    set push, token_newline
    jsr lexer_advance

:std_print_break_eof
    set c, 10
    jsr screen_add_char

    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_raise
;----------------------------------------------------------------
    ife [try_fp], 0
        jsr recover
        #doc Unhandled exception error

    jsr lexer_next        ; skip raise

    set x, NONE
    ife [lexer_token], token_newline
        set pc, std_raise_except
    ife [lexer_token], token_eof
        set pc, std_raise_except

    set push, 0
    jsr expression

:std_raise_except
    set z, [try_fp]
    set sp, [try_sp]
    set [try_fp], pop
    set [try_sp], pop

    set [z-1], x
    jsr lexer_restore
    jsr parser_skip_suite

    set push, token_except          ; verify except
    jsr lexer_advance

    ife [lexer_token], token_colon
        set pc, std_raise_finish

    ; get the testlist (left side)
    set push, 0x0000
    jsr testlist
    set [z-2], x

    set push, x
    set push, [z-1]
    jsr assign

:std_raise_finish
    set push, token_colon           ; verify colon
    jsr lexer_advance

    jsr parser_suite                ; process except block

    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, postamble

    set x, VOID
    set pc, postamble


;----------------------------------------------------------------
:std_return
;----------------------------------------------------------------
    jsr lexer_next        ; skip return

    set push, SIZEOF_CONTROL            ; create struct control
    set push, TYPE_CONTROL
    jsr array_create
    set [z-1], x

    set a, [x]
    set [a + CONTROL_SIGNAL], CONTROL_SIGNAL_RETURN  ; set control type
    set [a + CONTROL_VALUE], NONE                    ; default: no return value

    ife [lexer_token], token_newline
        set pc, std_return_finish
    ife [lexer_token], token_eof
        set pc, std_return_finish

    set push, 0
    jsr expression

    set a, [z-1]
    set a, [a]
    set [a + CONTROL_VALUE], x

:std_return_finish
    ; keeping lexer up to date is not needed after return
    ; set push, token_newline
    ; jsr lexer_advance

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
:std_break
;----------------------------------------------------------------
    set b, CONTROL_SIGNAL_BREAK            ; store token for control signal
    set pc, std_continue_and_break

;----------------------------------------------------------------
:std_continue
;----------------------------------------------------------------
    set b, CONTROL_SIGNAL_CONTINUE            ; store token for control signal

:std_continue_and_break
    jsr lexer_next                    ; advance 'break' or 'continue'

    ifn [lexer_token], token_newline
        ifn [lexer_token], token_eof
            jsr recover
            #doc break and continue must end line error

    jsr lexer_next                    ; advance newline or eof

    set push, SIZEOF_CONTROL        ; create struct control
    set push, TYPE_CONTROL
    jsr array_create

    set a, [x]
    set [a + CONTROL_SIGNAL], b     ; set control signal
    set [a + CONTROL_VALUE], VOID    ; default: no return value
    set pc, postamble

;----------------------------------------------------------------
:std_pass
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next

    ifn [lexer_token], token_newline
        ifn [lexer_token], token_eof
            jsr recover
            #doc pass must end line error

    set x, VOID
        set pc, postamble

;----------------------------------------------------------------
:std_for
; for x in list:
;  print x
; return VOID
; TODO 'else'
; Comments:
; Python grammar uses valid operator 'in' as for loop
; separator. there is no way for parser to detect between expression
; operator and for separator.
;----------------------------------------------------------------
    jsr lexer_next                ; advance 'for'

    ; get the testlist (left side)
    set push, 0x0000
    jsr testlist
    set [z-3], x

    set push, token_in    ; verify 'in'
    jsr lexer_advance

    ; get the exprlist (right side)
    set push, 0x0000
    jsr expression
    set [z-4], x

    set push, x
    jsr eval
    set [z-4], x

    set push, token_colon        ; verify colon
    jsr lexer_advance

    jsr lexer_store                ; store lexer position

    set i, 0

:std_for_loop
    set a, [z-3]   ; struct handle *left
    set b, [z-4]   ; struct handle *right

    set c, [b]        ; struct data *right
    ife i, [c]        ; i == rightLen -> done
        set pc, std_for_finish

    add c, i        ; c+1 = points to current item
    ifb [b + HANDLE_TYPE], TYPE_STR
        set pc, std_for_loop_string

    set push, a
    set push, [c+1]
    jsr assign

:std_for_execute_suite
    jsr parser_suite
    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, std_for_control
;    ife [lexer_token], token_eof
;        set pc, std_for_eof

:std_for_control_continue
    jsr lexer_restore                ; restore lexer to loop condition
    sti pc, std_for_loop

:std_for_loop_string
    ifb [a + HANDLE_TYPE], TYPE_TUPLE
        set pc, std_for_loop_string_tuple

    set push, a
    set push, [c+1]
    jsr assign_from_string

    set pc, std_for_execute_suite

:std_for_loop_string_tuple
    set push, a
    set push, b
    jsr assign

    set pc, std_for_execute_suite

:std_for_control
    set a, [x]
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_CONTINUE
        set pc, std_for_control_continue
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_BREAK
        set pc, std_for_control_break
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_RETURN
        set pc, postamble

    jsr recover
    #doc for loop not terminated by continue, break or return -error

:std_for_control_break
    jsr lexer_restore

:std_for_finish
    jsr parser_skip_suite

:std_for_eof
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_del
;----------------------------------------------------------------
    jsr lexer_next            ; advance 'del'

:std_del_loop
    ife [lexer_token], token_newline
        set pc, std_del_break
    ife [lexer_token], token_eof
        set pc, std_del_break

    set push, 0
    jsr expression
    set [z-1], x

    set push, x
    jsr del

    set pc, std_del_loop

:std_del_break
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_try
;----------------------------------------------------------------
    jsr lexer_next                  ; advance 'try'

    set push, token_colon           ; verify colon
    jsr lexer_advance

    jsr lexer_store                 ; store lexer position

    set push, [try_sp]
    set push, [try_fp]
    set [try_sp], sp
    set [try_fp], z

    jsr parser_suite                ; process try block
    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, std_try_finish

    set push, token_except          ; verify except
    jsr lexer_advance

    set push, token_colon           ; skip test list
    jsr parser_skip_until_token

    jsr lexer_next                  ; skip colon

    jsr parser_skip_suite           ; skip except block

    set x, VOID
:std_try_finish
    set [try_fp], pop
    set [try_sp], pop

    set pc, postamble


;----------------------------------------------------------------
:std_if
; return struct handle *none
;----------------------------------------------------------------
    jsr lexer_next            ; advance 'if'

    set push, 0            ; evaluate if condition
    jsr expression
    set [z-3], x

    set push, x
    jsr eval
    set [z-3], x

    set push, x
    jsr boolean
    set [z-3], x

    set push, token_colon        ; verify colon
    jsr lexer_advance

    ife [z-3], BOOL_FALSE   ; break if loop condition is false
        set pc, std_if_false

    jsr parser_suite
    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, postamble
    ife [lexer_token], token_eof
        set pc, std_if_eof

    set pc, std_if_skip

:std_if_skip_loop
    set push, token_colon
    jsr parser_skip_until_token

    jsr lexer_next            ; skip COLON

    jsr parser_skip_suite
    ife [lexer_token], token_eof
        set pc, std_if_eof

:std_if_skip
    ife [lexer_token], token_elif
        set pc, std_if_skip_loop
    ife [lexer_token], token_else
        set pc, std_if_skip_loop

    set pc, std_if_eof

:std_if_false
    jsr parser_skip_suite
    ife [lexer_token], token_elif
        set pc, std_if
    ife [lexer_token], token_else
        set pc, std_if_else

    set pc, std_if_eof

:std_if_else
    jsr lexer_next        ; skip else

    set push, token_colon
    jsr lexer_advance    ; skip COLON

    jsr parser_suite

    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, postamble

:std_if_eof
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
:std_while
; return struct handle *none
; todo implement else
;----------------------------------------------------------------
    jsr lexer_next                ; advance 'while'

    jsr lexer_store                ; store lexer position

:std_while_loop
    set push, 0                    ; evaluate loop condition
    jsr expression
    set [z-3], x

    set push, x
    jsr boolean
    set [z-3], x

    set push, token_colon        ; verify colon
    jsr lexer_advance

    ife [z-3], BOOL_FALSE   ; break if loop condition is false
        set pc, std_while_false

    jsr parser_suite
    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, std_while_control
;    ife [lexer_token], token_eof
;        set pc, std_while_eof

:std_while_control_continue
    jsr lexer_restore                ; restore lexer to loop condition
    set pc, std_while_loop

:std_while_control
    set a, [x]
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_CONTINUE
        set pc, std_while_control_continue
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_BREAK
        set pc, std_while_control_break
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_RETURN
        set pc, postamble

    jsr recover
    #doc assertion failed, unknown control signal terminated while loop

:std_while_control_break
    jsr lexer_restore

    set push, token_colon
    jsr parser_skip_until_token

    jsr lexer_next        ; skip colon

:std_while_false
    jsr parser_skip_suite

:std_while_eof
    set x, VOID
    set pc, postamble

;----------------------------------------------------------------
; void parser_skip_until_token()
;----------------------------------------------------------------
:parser_skip_until_token
    ife [lexer_token], [sp + 1]
        set pc, parser_skip_until_token_finish
    ife [lexer_token], token_eof
        set pc, parser_skip_until_token_finish

    jsr lexer_next
    set pc, parser_skip_until_token

:parser_skip_until_token_finish
    set [sp], pop
    set pc, pop

;----------------------------------------------------------------
; void parser_skip_suite()
;----------------------------------------------------------------
:parser_skip_suite
;    set push, 0
;    set push, 0
;    jsr preamble

    ife [lexer_token], token_newline
        set pc, parser_skip_suite_block

:parser_skip_suite_simple_stmt
    set push, token_newline
    jsr parser_skip_until_token

:parser_skip_suite_simple_stmt_finish
    jsr lexer_next        ; skip newline
    set pc, pop

:parser_skip_suite_block
    jsr lexer_next        ; skip newline

    set push, token_indent    ; verify indent
    jsr lexer_advance

    set push, 1

:parser_skip_suite_block_loop
    ife [lexer_token], token_indent
        add [sp], 1
    ife [lexer_token], token_dedent
        sub [sp], 1

    jsr lexer_next

    ifn [sp], 0
        set pc, parser_skip_suite_block_loop

;    add sp, 1
    set ex, pop     ; pop value to dev/null
    set pc, pop


;----------------------------------------------------------------
; void parser_suite()
;----------------------------------------------------------------
:parser_suite
    set push, 0
    set push, 0
    jsr preamble

    ife [lexer_token], token_newline
        set pc, parser_suite_block

:parser_suite_simple_stmt
    jsr parser_simple_stmt
    set pc, postamble

:parser_suite_block
    jsr lexer_next        ; skip newline

    set push, token_indent    ; verify indent
    jsr lexer_advance

:parser_suite_block_loop
    jsr parser_stmt

    ifb [x + HANDLE_TYPE], TYPE_CONTROL
        set pc, postamble

    ife [lexer_token], token_dedent
        set pc, parser_suite_block_break

    ife [lexer_token], token_eof
        set pc, postamble

    set pc, parser_suite_block_loop

:parser_suite_block_break
    set push, x
    jsr lexer_next    ; skip dedent
    set x, pop
    set pc, postamble

;----------------------------------------------------------------
:std_expression
;----------------------------------------------------------------
    set push, 0
    jsr expression

    set pc, postamble

;----------------------------------------------------------------
; struct handle *expression(uint16 rbp)
;----------------------------------------------------------------
:expression
    set push, 1
    set push, 1            ; struct handle *left
    jsr preamble

    set b, [z+10]        ; rbp

    set c, [lexer_token]
    jsr [c + PROTOTYPE_NUD]
    #doc Syntax error

    set [z-1], x       ; struct handle *left

:expr_loop
    set c, [lexer_token]

    ifg b, [c + PROTOTYPE_LBP]
        set pc, expr_finish
    ife b, [c + PROTOTYPE_LBP]
        set pc, expr_finish

    set push, [z-1]
    jsr [c + PROTOTYPE_LED]
:expression_callback
    set [z-1], x        ; struct handle *left

    set pc, expr_loop

:expr_finish
    set x, [z-1]       ; struct handle *left
    set pc, postamble

;----------------------------------------------------------------
; struct handle *testlist(uint16 rbp)
;----------------------------------------------------------------
:testlist
    set push, 1
    set push, 1            ; struct handle *left
    jsr preamble

    set b, [z+10]        ; rbp

    set y, 0
    ife [lexer_token], token_name
        set y, nud_name
    ife [lexer_token], token_lparen
        set y, nud_lparen

    ife y, 0
        jsr recover
        #doc Illegal list definition error

    jsr y
    set [z-1], x       ; struct handle *left

:testlist_loop
    set c, [lexer_token]

    ifg b, [c + PROTOTYPE_LBP]
        set pc, expr_finish
    ife b, [c + PROTOTYPE_LBP]
        set pc, expr_finish

    set y, 0
    ife c, token_lbrack
        set y, led_lbrack
    ife c, token_reference
        set y, led_reference
    ife c, token_comma
        set y, led_comma

    ife y, 0
        set pc, expr_finish

    set push, [z-1]
    jsr y
:testlist_callback
    set [z-1], x       ; struct handle *left

    set pc, testlist_loop

;----------------------------------------------------------------
; struct handle *nud_int()
;----------------------------------------------------------------
:nud_str
:nud_name
    jsr lexer_get_token_as_string
    set [z-1], x

    jsr lexer_next

    set x, [z-1]
    set pc, pop

:nud_hex
    set a, int_parse_hex
    set pc, nud_generic

:nud_float
    set a, float__from_str
    set pc, nud_generic

:nud_int
    set a, int_parse

:nud_generic
    jsr lexer_get_token_as_string
    set [z-1], x

    set push, x
    jsr a
    set [z-1], x

    jsr lexer_next

    set x, [z-1]
    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_none()
;----------------------------------------------------------------
:nud_none
    jsr lexer_next
    set x, NONE
    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_true()
;----------------------------------------------------------------
:nud_true
    jsr lexer_next
    set x, BOOL_TRUE
    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_false()
;----------------------------------------------------------------
:nud_false
    jsr lexer_next
    set x, BOOL_FALSE
    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_lparen()
; expression or tuple
;----------------------------------------------------------------
:nud_lparen
    set push, 0
    set push, 1
    jsr preamble

    jsr lexer_next    ; skip '('

    ife [lexer_token], token_rparen
        set pc, nud_lparen_empty

    set push, 0
    jsr expression
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
        set [x + HANDLE_TYPE], TYPE_TUPLE

    set push, token_rparen
    jsr lexer_advance

    set x, [z-1]
    set pc, postamble

:nud_lparen_empty
    jsr lexer_next    ; skip ')'

    set push, 0
    set push, TYPE_TUPLE
    jsr array_create

    set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_lbrack()
; list
;----------------------------------------------------------------
:nud_lbrack
    set push, 0
    set push, 2
    jsr preamble

    jsr lexer_next    ; skip '['

    ife [lexer_token], token_rbrack
        set pc, nud_lbrack_empty

    set push, 0
    jsr expression
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
        set pc, nud_lbrack_change_type

    set push, 5
    set push, TYPE_LIST
    jsr alloc
    set [z-2], x

    set a, [x]
    set [a], 1
    set [a+1], [z-1]
    set pc, nud_lbrack_continue

:nud_lbrack_change_type
    set [x + HANDLE_TYPE], TYPE_LIST
    set [z-2], x

:nud_lbrack_continue
    set push, token_rbrack
    jsr lexer_advance

    set x, [z-2]
    set pc, postamble

:nud_lbrack_empty
    jsr lexer_next    ; skip ']'

    set push, 5
    set push, TYPE_LIST
    jsr alloc

    set pc, postamble
;----------------------------------------------------------------
; struct handle *nud_lcurly()
; dict
;----------------------------------------------------------------
:nud_lcurly
    set push, 0
    set push, 3
    jsr preamble

    set push, 5
    set push, TYPE_DICT
    jsr alloc
    set [z-1], x

:nud_lcurly_loop
    jsr lexer_next    ; skip '{' or ','

    ife [lexer_token], token_rcurly
        set pc, nud_lcurly_finish

    ; left side (key)
    set push, 0
    jsr expression
    set [z-2], x

    set push, x
    jsr eval
    set [z-2], x

    set push, token_colon
    jsr lexer_advance        ; skip ':'

    ; right side (value)
    set push, 0x0030        ; break at comma
    jsr expression
    set [z-3], x

    set push, x
    jsr eval
    set [z-3], x

    ; kv-pair
    ; set push, 2
    ; set push, TYPE_TUPLE
    ; jsr array_create
    ; set [z-2], x

    ; set a, [x]
    ; set [a + DICT_ITEM_KEY],   [z-3]
    ; set [a + DICT_ITEM_VALUE], [z-4]

    set push, [z-1]
    set push, [z-2]
    set push, [z-3]
    jsr dict__set

    ife [lexer_token], token_comma
        set pc, nud_lcurly_loop

:nud_lcurly_finish
    set push, token_rcurly
    jsr lexer_advance

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_plus()
;----------------------------------------------------------------
:nud_plus
    jsr lexer_next

    set push, 0x0150
    jsr expression

    set pc, pop

;----------------------------------------------------------------
; struct handle *nud_minus()
;----------------------------------------------------------------
:nud_minus
    set push, 0
    set push, 1
    jsr preamble

    jsr lexer_next

    set push, 0x0150
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    set y, 0
    ifb [x + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
        set y, int_negate
    ifb [x + HANDLE_TYPE], TYPE_FLOAT
        set y, float__negate

    ife y, 0
        jsr recover
        #doc Only number types can be used in subtract operation

    set push, x
    jsr y

    set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_tilde()
;----------------------------------------------------------------
:nud_tilde
    set push, 0
    set push, 1
    jsr preamble

    jsr lexer_next

    set push, 0x0160
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_INT + TYPE_BOOL
        set pc, nud_tilde_int

    jsr recover
        #doc Only integer and boolean types can be used in negate operation

:nud_tilde_int
    set push, x
    jsr int_complement

    set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_not()
;----------------------------------------------------------------
:nud_not
    set push, 0
    set push, 1
    jsr preamble

    jsr lexer_next

    set push, 0x0055
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    set push, x
    jsr boolean
    set a, x

    set x, BOOL_FALSE
    ife a, BOOL_FALSE
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_and(struct handle *left)
;----------------------------------------------------------------
:led_and
    set push, 1
    set push, 1
    jsr preamble

    set x, [lexer_token]
    set push, [x + PROTOTYPE_LBP]        ; push for expression call

    ; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    set push, x
    jsr boolean
    set [z-1], x

    jsr lexer_next

    ; right side
    jsr expression

    ife [z-1], BOOL_FALSE
        set pc, led_and__finish

    set [z-1], x

    ; evaluate right side
    set push, x
    jsr eval
    set [z-1], x

    set push, x
    jsr boolean
    set [z-1], x

:led_and__finish
    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_or(struct handle *left)
;----------------------------------------------------------------
:led_or
    set push, 1
    set push, 2
    jsr preamble

    set x, [lexer_token]
    set push, [x + PROTOTYPE_LBP]        ; push for expression call

    ; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    set push, x
    jsr boolean
    set [z-2], x

    jsr lexer_next

    ; right side
    jsr expression

    ife [z-2], BOOL_TRUE
        set pc, led_or__finish

    set [z-2], x

    ; evaluate right side
    set push, x
    jsr eval
    set [z-1], x

:led_or__finish
    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_is(struct handle *left)
;----------------------------------------------------------------
:led_is
    set push, 1
    set push, 2
    jsr preamble

    set a, TRUE

    jsr lexer_next
    ifn [lexer_token], token_not
        set a, FALSE
    ife [lexer_token], token_not
        jsr lexer_next

    ; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    ; parse right side
    set push, 0x0070
    jsr expression
    set [z-2], x

    ; evaluate right side
    set push, [z-2]
    jsr eval
    set [z-2], x

    ife a, TRUE
        set pc, led_is_not

    set x, BOOL_FALSE
    ife [z-2], [z-1]
        set x, BOOL_TRUE

    set pc, postamble

:led_is_not
    set x, BOOL_TRUE
    ife [z-2], [z-1]
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_not(struct handle *left)
;----------------------------------------------------------------
:led_not
    set push, 1
    set push, 2
    jsr preamble

    jsr lexer_next    ; advance not

    set a, TRUE
    set pc, led_in_1

;----------------------------------------------------------------
; struct handle *led_in(struct handle *left)
;----------------------------------------------------------------
:led_in
    set push, 1
    set push, 2
    jsr preamble

    set a, FALSE

:led_in_1
    set push, token_in
    jsr lexer_advance    ; verify led

; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    ; parse right side
    set push, 0x0060
    jsr expression
    set [z-2], x

    ; evaluate right side
    set push, [z-2]
    jsr eval
    set [z-2], x

    ifb [x + HANDLE_TYPE], TYPE_STR
        set pc, led_in_string

    ifb [x + HANDLE_TYPE], TYPE_DICT
        set pc, led_in_dict

    ifb [x + HANDLE_TYPE], TYPE_TUPLE + TYPE_LIST
        set pc, led_in_list

    jsr recover
    #doc Right side of "in" is not container or string error

:led_in_string
    set push, x
    set push, [z-1]
    jsr str_search
    ife x, -1
        set pc, led_in_not_found
    set pc, led_in_found

:led_in_dict
    set push, x
    set push, [z-1]
    jsr dict_get
    ife x, 0
        set pc, led_in_not_found
    set pc, led_in_found

:led_in_list
    set push, x
    set push, [z-1]
    jsr array_find
    ife x, -1
        set pc, led_in_not_found

:led_in_found
    set x, BOOL_TRUE
    ife a, TRUE
        set x, BOOL_FALSE

    set pc, postamble

:led_in_not_found
    set x, BOOL_FALSE
    ife a, TRUE
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_less_or_equal(struct handle *left)
;----------------------------------------------------------------
:led_less_or_equal
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_TRUE
    ife a, 1
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_less(struct handle *left)
;----------------------------------------------------------------
:led_less
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_FALSE
    ife a, -1
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_greater_or_equal(struct handle *left)
;----------------------------------------------------------------
:led_greater_or_equal
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_TRUE
    ife a, -1
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_greater(struct handle *left)
;----------------------------------------------------------------
:led_greater
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_FALSE
    ife a, 1
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_not_equal(struct handle *left)
;----------------------------------------------------------------
:led_not_equal
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_FALSE
    ifn a, 0
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_equal(struct handle *left)
;----------------------------------------------------------------
:led_equal
    set push, 1
    set push, 2
    jsr preamble

    jsr compare_operator

    set x, BOOL_FALSE
    ife a, 0
        set x, BOOL_TRUE

    set pc, postamble

:compare_operator
    jsr lexer_next

    ; right side
    set push, 0x0080
    jsr expression
    set [z-2], x

    ; evaluate left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    ; evaluate right side
    set push, [z-2]
    jsr eval
    set [z-2], x

    set push, [z-1]
    set push, [z-2]
    jsr val_cmp
    set a, x

    set pc, pop

;----------------------------------------------------------------
; struct handle *led_plus(struct handle *left)
;----------------------------------------------------------------
:led_plus
    ; todo str+str, tuple+tuple, list+list, int+int, float+int, int+float, float+float
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_plus_operation

    set pc, postamble

:led_plus_operation
    jsr cast_common_number_type
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_add
    ife c, TYPE_FLOAT
        set y, float__add
    ife c, TYPE_STR
        set y, array_merge
    ife c, TYPE_LIST
        set y, array_merge
    ife c, TYPE_TUPLE
        set y, array_merge

:led_operation_tailer
    set push, a
    set push, b
    jsr y

    set pc, pop

;----------------------------------------------------------------
; struct handle *led_minus(struct handle *left)
;----------------------------------------------------------------
:led_minus
    ; todo int-int, float-int, int-float, float-float
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_minus_operation

    set pc, postamble

:led_minus_operation
    jsr cast_common_number_type
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_sub
    ife c, TYPE_FLOAT
        set y, float__sub

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_star(struct handle *left)
;----------------------------------------------------------------
:led_star
    ; todo int*int, int*float, float*int, float*float, int*str, str*int, int*tuple, tuple*int, int*list, list*int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_star_operation

    set pc, postamble

:led_star_operation
    jsr cast_common_number_type
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_mul
    ife c, TYPE_FLOAT
        set y, float__mul
    ife c, TYPE_STR + TYPE_INT
        set y, array_repeat
    ife c, TYPE_TUPLE + TYPE_INT
        set y, array_repeat
    ife c, TYPE_LIST + TYPE_INT
        set y, array_repeat

    ifc [a + HANDLE_TYPE], TYPE_INT
        set pc, led_operation_tailer

    ; swap a and b
    set ex, a
    set a, b
    set b, ex

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_power(struct handle *left)
;----------------------------------------------------------------
:led_power
    ; todo int*int, int*float, float*int, float*float
    set push, 1
    set push, 2
    jsr preamble

    jsr infixr
    jsr led_power_operation

    set pc, postamble

:led_power_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_pow

    ifb [a + HANDLE_TYPE], TYPE_FLOAT
        ifb [b + HANDLE_TYPE], TYPE_INT
            set y, float__pow

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_bitwise_or(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_or
    ; int*int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_bitwise_or_operation

    set pc, postamble

:led_bitwise_or_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_bitwise_or

    set pc, led_operation_tailer


;----------------------------------------------------------------
; struct handle *led_bitwise_xor(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_xor
    ; int*int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_bitwise_xor_operation

    set pc, postamble

:led_bitwise_xor_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_bitwise_xor

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_bitwise_and(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_and
    ; int*int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_bitwise_and_operation

    set pc, postamble

:led_bitwise_and_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_bitwise_and

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_lshift(struct handle *left)
;----------------------------------------------------------------
:led_lshift
    ; int << int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_lshift_operation

    set pc, postamble

:led_lshift_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_lshift

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_rshift(struct handle *left)
;----------------------------------------------------------------
:led_rshift
    ; int >> int
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_rshift_operation

    set pc, postamble

:led_rshift_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_rshift

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_slash(struct handle *left)
;----------------------------------------------------------------
:led_slash
    ; todo int/int, int/float, float/int, float/float
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_slash_operation

    set pc, postamble

:led_slash_operation
    jsr cast_common_number_type
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_div
    ife c, TYPE_FLOAT
        set y, float__div

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_percent(struct handle *left)
;----------------------------------------------------------------
:led_percent
    ; todo int/int, int/float, float/int, float/float
    set push, 1
    set push, 2
    jsr preamble

    jsr infix
    jsr led_percent_operation

    set pc, postamble

:led_percent_operation
    set c, [a + HANDLE_TYPE]
    bor c, [b + HANDLE_TYPE]

    ifc c, TYPE_GROUP_NON_INTEGER
        set y, int_mod

    set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_assign(struct handle *left)
;----------------------------------------------------------------
:led_assign
    set push, 1
    set push, 1
    jsr preamble

    jsr lexer_next

    ; right side
    set push, 0x0009                     ; right binding power
    jsr expression
    set [z-1], x

    set push, x
    jsr eval
    set [z-1], x

    set push, [z+10]
    set push, x
    jsr assign

    set pc, postamble

;----------------------------------------------------------------
:led_augass
;----------------------------------------------------------------
    ; we cheat here, as stack is wrongly organized
    ; z+10
    ; rts
    ; z+11
    ; we must copy rts and z11 to get proper stack bottom
    set push, [sp+2]
    set push, [sp+2]

    ; here we claim 4 parameters, to make postamble clean them all
    set push, 4
    set push, 2
    jsr preamble

    jsr infixr

    jsr [z+11]
    set [z-1], x

    set push, [z+10]
    set push, x
    jsr assign

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_augass_lshift(struct handle *left)
;----------------------------------------------------------------
:led_augass_lshift
    set push, led_lshift_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_rshift(struct handle *left)
;----------------------------------------------------------------
:led_augass_rshift
    set push, led_rshift_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_or(struct handle *left)
;----------------------------------------------------------------
:led_augass_or
    set push, led_bitwise_or_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_xor(struct handle *left)
;----------------------------------------------------------------
:led_augass_xor
    set push, led_bitwise_xor_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_and(struct handle *left)
;----------------------------------------------------------------
:led_augass_and
    set push, led_bitwise_and_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_plus(struct handle *left)
;----------------------------------------------------------------
:led_augass_plus
    set push, led_plus_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_minus(struct handle *left)
;----------------------------------------------------------------
:led_augass_minus
    set push, led_minus_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_star(struct handle *left)
;----------------------------------------------------------------
:led_augass_star
    set push, led_star_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_slash(struct handle *left)
;----------------------------------------------------------------
:led_augass_slash
    set push, led_slash_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_percent(struct handle *left)
;----------------------------------------------------------------
:led_augass_percent
    set push, led_percent_operation
    set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_lparen(struct handle *left)
; function call
;----------------------------------------------------------------
:led_lparen
    set push, 1
    set push, 5
    jsr preamble

    set pc, built_in

:led_lparen_user_defined
    ; prepare scope
    set push, 10        ; create scope for function call
    set push, TYPE_DICT
    jsr alloc
    set [z-1], x

    set push, x            ; add global scope (ex)
    set push, STR_EX
    set push, [global_scope]
    jsr dict__set

    ; create tuple for arguments
    set push, 5
    set push, TYPE_TUPLE
    jsr alloc
    set [z-4], x

    ; add argument tuple to function scope
    set push, [z-1]
    set push, STR_ARGV
    set push, x
    jsr dict__set

    set a, [z+10]        ; if call is by reference, add path dict to scope (me)
    ifc [a + HANDLE_TYPE], TYPE_GROUP_SELF_AWARE
        set pc, led_lparen_args

    set a, [a]            ; a = struct reference *

    set push, [z-1]
    set push, STR_ME
    set push, [a + REFERENCE_OR_SUBSCRIPTION_ROOT]
    jsr dict__set

:led_lparen_args
    jsr lexer_next    ; skip '(' or ','

    ife [lexer_token], token_rparen
        set pc, led_lparen_prepare_call

    ; read value or name
    set push, 0x0030
    jsr expression
    set [z-2], x

    ife [lexer_token], token_assign
        ; key=value
        set pc, parse_testlist_item_assign

    ; argv[n]=value
    set push, x
    jsr eval
    set [z-2], x

    set push, [z-4]
    set push, x
    jsr array__append

    set pc, led_lparen_arg_loop_condition

:parse_testlist_item_assign
    ; f(a=1)
    ifc [x + HANDLE_TYPE], TYPE_NAME
        jsr recover
        #doc Invalid name for function call parameter error

    jsr lexer_next    ; skip '='

    ; read value
    set push, 0x0030
    jsr expression
    set [z-3], x

    set push, x
    jsr eval
    set [z-3], x

    set push, [z-1]
    set push, [z-2]
    set push, [z-3]
    jsr dict__set

:led_lparen_arg_loop_condition
    ife [lexer_token], token_comma
        set pc, led_lparen_args

:led_lparen_prepare_call
    set push, token_rparen
    jsr lexer_advance    ; skip ')'

    set push, [z+10]
    jsr eval
    set [z-2], x

    ifc [x + HANDLE_TYPE], TYPE_STR
        jsr recover
        #doc Only strings are callable error

    set push, [current_scope]
    set [current_scope], [z-1]

    jsr lexer_store

    set x, [z-2]
    jsr lexer_init

:led_lparen_call
    jsr parser_stmt
    set [z-3], x

    ifb [x+HANDLE_TYPE], TYPE_CONTROL
        set pc, led_lparen_control

    ifn [lexer_token], token_eof
        set pc, led_lparen_call

    set a, NONE

:led_lparen_finish
    jsr lexer_restore
    set [current_scope], [sp+6]
    set x, a
    set pc, postamble

:led_lparen_control
    set a, [x]
    ifb [a + CONTROL_SIGNAL], CONTROL_SIGNAL_RETURN
        set pc, led_lparen_control_return

    jsr recover
    #doc Assertion failed: Illegal control signal in function return

:led_lparen_control_return
    set push, [a + CONTROL_VALUE]
    jsr eval
:led_lparen_control_raise
    set a, x

    set pc, led_lparen_finish

;----------------------------------------------------------------
:parse_testlist_item
;----------------------------------------------------------------
    set pc, pop

;----------------------------------------------------------------
; struct handle *led_lbrack(struct handle *left)
;----------------------------------------------------------------
:led_lbrack
    set push, 1
    set push, 3
    jsr preamble

    jsr lexer_next            ; skip '['

    ; eval left side
    set push, [z+10]
    jsr eval
    set [z-1], x

    ifb [x + HANDLE_TYPE], TYPE_DICT    ; branch dict
        set pc, led_lbrack_dict

    ifc [x + HANDLE_TYPE], TYPE_STR + TYPE_TUPLE + TYPE_LIST
        jsr recover
        #doc Element subscription is available only for dict, string, tuple and list

    ; handle str, tuple, list
    ifn [lexer_token], token_colon
        set pc, led_lbrack_parse_first

    ; no slice start, assume 0
    set [z-2], INT_0
    set pc, led_lbrack_after_colon

:led_lbrack_parse_first
    ; parse slice start or index
    set push, 0
    jsr expression
    set [z-2], x

    set push, x
    jsr eval
    set [z-2], x

    ifn [lexer_token], token_colon
        set pc, led_lbrack_finish    ; no colon -> index

:led_lbrack_after_colon
    jsr lexer_next                ; skip ':'
    ; [z-2] now contains slice start
    set [z-3], [z-2]

    set push, 2
    set push, TYPE_TUPLE
    jsr array_create
    set [z-2], x

    set x, [x]
    set [x+1], [z-3]           ; slice start

    ife [lexer_token], token_rbrack
        set pc, led_lbrack_empty_after_colon

    set push, 0
    jsr expression
    set [z-3], x

    set push, x
    jsr eval
    set [z-3], x

    set a, [z-2]
    set a, [a]
    set [a+2], [z-3]        ; slice end

    set pc, led_lbrack_finish

:led_lbrack_empty_after_colon
    ; set array len to slice end
    set a, [z-1]
    set a, [a]

    set push, [a]
    jsr  uint16_to_int
    set [z-3], x

    set a, [z-2]
    set a, [a]
    set [a+2], [z-3]        ; slice end

    set pc, led_lbrack_finish

:led_lbrack_dict
    set push, 0
    jsr expression
    set [z-2], x

    set push, x
    jsr eval
    set [z-2], x

    ifc [x + HANDLE_TYPE], TYPE_STR + TYPE_INT + TYPE_BOOL + TYPE_FLOAT + TYPE_NONE
        jsr recover
        #doc dict key is not recursively immutable error

:led_lbrack_finish
    set push, token_rbrack
    jsr lexer_advance

    ; construct return value
    set push, 2
    set push, TYPE_SUBSCRIPTION
    jsr array_create
    set [z-3], x            ; result

    set a, [x]
    set [a + SUBSCRIPTION_LIST], [z-1]
    set [a + SUBSCRIPTION_INDEX], [z-2]

    set pc, postamble

;----------------------------------------------------------------
; struct handle *led_reference(struct handle *left)
; attribute reference
;----------------------------------------------------------------
:led_reference
    set push, 1
    set push, 3
    jsr preamble

    set push, 2
    set push, TYPE_REFERENCE
    jsr array_create
    set [z-1], x

    set push, [z+10]
    jsr eval

    ifc [x + HANDLE_TYPE], TYPE_GROUP_CAN_REFERENCE
        jsr recover
        #doc Illegal reference from non string, list or dict error

    set a, [z-1]
    set a, [a]
    set [a + REFERENCE_LEFT], x

    jsr lexer_next

    ifn [lexer_token], token_name
        jsr recover
        #doc Illegal reference name

    jsr lexer_get_token_as_string
;    set [x + HANDLE_TYPE], TYPE_STR

    set a, [z-1]
    set a, [a]
    set [a + REFERENCE_RIGHT], x

    jsr lexer_next

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
:infixr
    set a, [lexer_token]
    set a, [a + PROTOTYPE_LBP]        ; push for expression call
    sub a, 1
    set push, a
    set pc, infix_1

;----------------------------------------------------------------
:infix
; fastcall
; return
;   a: struct handle *left
;   b: struct handle *right
;   y: 0
;----------------------------------------------------------------
    set a, [lexer_token]
    set push, [a + PROTOTYPE_LBP]        ; push for expression call

:infix_1
    ; left
    set push, [z+10]
    jsr eval
    set [z-1], x
    set a, x

    jsr lexer_next

    ; right side
    jsr expression
    set [z-2], x

    set push, x
    jsr eval
    set [z-2], x
    set b, x

    set y, recover

    set pc, pop

;----------------------------------------------------------------
; struct handle *led_comma(struct handle *left)
; tuple
;----------------------------------------------------------------
:led_comma
    set push, 1
    set push, 2
    jsr preamble

    set a, [z+10]
    set [z-1], a
    ifb [a + HANDLE_TYPE], TYPE_TUPLE_COMMA
        set pc, led_comma_add

    set push, 5
    set push, TYPE_TUPLE_COMMA
    jsr alloc
    set [z-1], x

    set x, [x]
    set [x], 1
    set [x+1], a

:led_comma_add
    jsr lexer_next

    set a, [lexer_token]
    ifn [a + PROTOTYPE_STD], std_expression
        set pc, led_comma_end

    set push, 0x0020
    ife [z+9], expression_callback
        jsr expression
    ife [z+9], testlist_callback
        jsr testlist
    set [z-2], x

    set push, [z-1]
    set push, [z-2]
    jsr array__append

:led_comma_end
    set x, [z-1]    ; expr
    set pc, postamble

;----------------------------------------------------------------
:built_in
;----------------------------------------------------------------
    set a, [z+10]
    ifb [a+HANDLE_TYPE], TYPE_NAME
        set pc, built_in__global_functions
    ifb [a+HANDLE_TYPE], TYPE_REFERENCE
        set pc, built_in__object_functions

    set pc, led_lparen_user_defined

:built_in__object_functions
    set a, [a]
    set b, [a + REFERENCE_LEFT]

    ; ADD HERE OBJECT TYPES THAT HAVE METHODS
    set x, 0
    ifb [b + HANDLE_TYPE], TYPE_LIST
        set x, built_in__list_methods
    ifb [b + HANDLE_TYPE], TYPE_STR
        set x, built_in__str_methods
    ifb [b + HANDLE_TYPE], TYPE_DICT
        set x, built_in__dict_methods

    ife x, 0
        set pc, led_lparen_user_defined

    set a, [a + REFERENCE_RIGHT]
    set a, [a]

    set b, [a]
    add a, 1

    jsr built_in_matcher
    set pc, c

:built_in__global_functions
    set a, [a]

    set b, [a]
    ifg b, 7
        set pc, led_lparen_user_defined

    add a, 1

    set x, [built_in_functions_by_len + b - 1]

    jsr built_in_matcher
    set pc, c

;----------------------------------------------------------------
DAT 0xffff
:built_in__object_method__init
;----------------------------------------------------------------
    jsr built_in_params

    set a, [z+10]
    set a, [a]
    set a, [a + REFERENCE_LEFT]

    set pc, pop

;----------------------------------------------------------------
:built_in__dict_create
;----------------------------------------------------------------
    jsr built_in__object_method__init

    ifn i, 0
        jsr recover
        #doc Wrong number of arguments for dict constructor (>0)

    set push, 5
    set push, TYPE_DICT
    jsr alloc
    set [z-1], x

    set push, x
    set push, STR_UNDERSCORE
    set push, a
    jsr dict__set

    set x, [z-1]
    set pc, postamble


;----------------------------------------------------------------
:built_in__list_append
;----------------------------------------------------------------
    jsr built_in__object_method__init

    ifn i, 1
        jsr recover
        #doc Wrong number of arguments for list append (1)

    set push, a
    set push, [z-1]
    jsr array__append

    set x, a
    set pc, postamble

;----------------------------------------------------------------
:built_in__list_insert
;----------------------------------------------------------------
    jsr built_in__object_method__init
    ifn i, 2
        jsr recover
        #doc Wrong number of arguments for list insert (2)

    set push, [z-1]        ; struct handle *index
    jsr int_to_int16

    set push, a
    set push, x
    set push, [z-2]
    jsr array__insert

    set x, a
    set pc, postamble

;----------------------------------------------------------------
DAT 0
DAT TYPE_STR + TYPE_BOOL + TYPE_NONE + TYPE_INT + TYPE_FLOAT + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
:built_in_id
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr uint16_to_int

    set pc, postamble

;----------------------------------------------------------------
DAT 0xffff
:built_in_input
;----------------------------------------------------------------
    jsr built_in_params

    ifg i, 1
        jsr recover
        #doc Wrong number of arguments for input()

    set push, [z-1]
    jsr raw_input
    set [z-1], x

    set a, [x]
    sub [a], 1

    set c, 10
    jsr screen_add_char

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
DAT 0xffff
:built_in_range
;----------------------------------------------------------------
    jsr built_in_params

    ife i, 0
        jsr recover
        #doc range() needs at least one argument

    ifg i, 1
        set pc, built_in_range_2

    set [z-2], [z-1]
    set [z-1], INT_0

:built_in_range_2
    ifg i, 2
        set pc, built_in_range_3

    set [z-3], INT_1

:built_in_range_3
    ifg i, 3
        jsr recover
        #doc Too many arguments for range()

    set a, [z-1]
    set b, [a + HANDLE_TYPE]
    set a, [z-2]
    bor b, [a + HANDLE_TYPE]
    set a, [z-3]
    bor b, [a + HANDLE_TYPE]

    ifn b, TYPE_INT
        jsr recover
        #doc range() arguments are not integers error

    set push, [z-3]
    jsr int_sgn
    set y, x
    mul y, -1

    set push, 20
    set push, TYPE_LIST
    jsr alloc
    set [z-4], x

    ife y, 0
        set pc, built_in_range_break

:built_in_range_loop
    set push, [z-1]
    set push, [z-2]
    jsr val_cmp

    ifn x, y
        set pc, built_in_range_break

    set push, [z-4]
    set push, [z-1]
    jsr array__append

    set push, [z-1]
    set push, [z-3]
    jsr int_add
    set [z-1], x

    set pc, built_in_range_loop

:built_in_range_break
    set x, [z-4]
    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_mem
;----------------------------------------------------------------
    jsr built_in_params

    iaq TRUE
    jsr mark
    jsr compact
    iaq FALSE

    set a, [heap_handle_start]
    sub a, [heap_free_start]

    set push, a
    jsr uint16_to_int

    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_exit
;----------------------------------------------------------------
    set z, [recovery_fp]
    set sp, [recovery_sp]

    set [current_scope], [global_scope]

    set pc, interpreter_loop

;----------------------------------------------------------------
DAT 0
:built_in_locals
;----------------------------------------------------------------
    jsr built_in_params

    set x, [current_scope]
    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_globals
;----------------------------------------------------------------
    jsr built_in_params

    set x, [global_scope]
    set pc, postamble

;----------------------------------------------------------------
DAT 0
DAT TYPE_STR + TYPE_BOOL + TYPE_NONE + TYPE_INT + TYPE_FLOAT + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
DAT TYPE_STR + TYPE_BOOL + TYPE_NONE + TYPE_INT + TYPE_FLOAT + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
:built_in_cmp
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    set push, [z-2]
    jsr val_cmp
    set a, x

    set x, INT_0
    ife a, -1
        set x, INT_N1
    ife a, 1
        set x, INT_1

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_chr
;----------------------------------------------------------------
    jsr built_in_params

    set a, [z-1]
    set a, [a]
    add a, [a]

    set push, 1
    set push, TYPE_STR
    jsr array_create

    set b, [x]
    set [b+1], [a]

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_STR
:built_in_ord
;----------------------------------------------------------------
    jsr built_in_params

    set a, [z-1]
    set a, [a]
    ifn [a], 1
        jsr recover
        #doc ord() can only be used for single character, not strings

    set push, [a+1]
    jsr uint16_to_int

    set pc, postamble

;----------------------------------------------------------------
DAT 0xffff
:built_in_edit
;----------------------------------------------------------------
    jsr built_in_params
    ifg i, 1
        jsr recover
        #doc Too many parameters for edit([str])

    set a, [z-1]
    ife i, 0
        set a, STR_EMPTY

    ifc [a + HANDLE_TYPE], TYPE_STR
        jsr recover
        #doc Illegal parameter type for edit(str)

    set push, a
    jsr edit_main

    set pc, postamble

;----------------------------------------------------------------
DAT 0xffff
:built_in_rnd
;----------------------------------------------------------------
    jsr built_in_params
    ifg i, 0
        set pc, built_in_rnd_1

    set a, FLOAT_0
    set b, FLOAT_1

    set pc, built_in_rnd_finish

:built_in_rnd_1
    ifg i, 1
        set pc, built_in_rnd_2

    set b, [z-1]
    set c, [b + HANDLE_TYPE]

    ifc c, TYPE_INT + TYPE_FLOAT
        jsr recover
        #doc rnd(): Type mismatch error

    set a, INT_0
    ife c, TYPE_FLOAT
        set a, FLOAT_0

    set pc, built_in_rnd_finish

:built_in_rnd_2
    set a, [z-1]
    set b, [z-2]

    ifc [a + HANDLE_TYPE], TYPE_FLOAT + TYPE_INT
        jsr recover
        #doc rnd(): Type mismatch error
    ifc [b + HANDLE_TYPE], TYPE_FLOAT + TYPE_INT
        jsr recover
        #doc rnd(): Type mismatch error

:built_in_rnd_finish
    jsr cast_common_number_type

    set y, int_random
    ifb [a + HANDLE_TYPE], TYPE_FLOAT
        set y, float__random

    set push, a
    set push, b
    jsr y

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT + TYPE_FLOAT
:built_in_abs
;----------------------------------------------------------------
    jsr built_in_params

    set a, [z-1]
    set push, a

    ifb [a + HANDLE_TYPE], TYPE_INT
        jsr int_abs
    ifb [a + HANDLE_TYPE], TYPE_FLOAT
        jsr float__abs

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_STR + TYPE_TUPLE + TYPE_DICT + TYPE_LIST
:built_in_len
;----------------------------------------------------------------
    jsr built_in_params

    set a, [z-1]
    set a, [a]

    set push, [a]
    jsr uint16_to_int

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_STR + TYPE_BOOL + TYPE_NONE + TYPE_INT + TYPE_FLOAT + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
:built_in_type
;----------------------------------------------------------------
    jsr built_in_params

    set x, [z-1]
    set push, [x + HANDLE_TYPE]
    jsr uint16_to_int

    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_dir
;----------------------------------------------------------------
    jsr built_in_params

    ife [floppy], 0xffff
        jsr recover
        #doc dir(): M35FD device not present error

    jsr floppy__dir__read

    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_format
;----------------------------------------------------------------
    jsr built_in_params

    ife [floppy], 0xffff
        jsr recover
        #doc format(): M35FD device not present error

    jsr floppy__format

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_STR
:built_in_load
;----------------------------------------------------------------
    jsr built_in_params

    ife [floppy], 0xffff
        jsr recover
        #doc load(): M35FD device not present error

    set push, [z-1]
    jsr floppy__file__read

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_STR, TYPE_STR + TYPE_BOOL + TYPE_NONE + TYPE_INT + TYPE_FLOAT + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
:built_in_save
;----------------------------------------------------------------
    jsr built_in_params

    ife [floppy], 0xffff
        jsr recover
        #doc save(): M35FD device not present error

    set push, [z-1]
    set push, [z-2]
    jsr floppy__file__write

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_STR
:built_in_rm
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr floppy__file__delete

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_STR + TYPE_BOOL + TYPE_INT + TYPE_FLOAT
:built_in_int
;----------------------------------------------------------------
    jsr built_in_params

    set a, [z-1]

    ifb [a + HANDLE_TYPE], TYPE_BOOL
        set pc, built_in_int_bool
    ifb [a + HANDLE_TYPE], TYPE_STR
        set pc, built_in_int_string
    ifb [a + HANDLE_TYPE], TYPE_FLOAT
        set pc, built_in_int_float

:built_in_int_int
    set x, a
    set pc, postamble

:built_in_int_bool
    ife a, BOOL_FALSE
        set x, INT_0
    ife a, BOOL_TRUE
        set x, INT_1
    set pc, postamble

:built_in_int_string
    set push, a
    jsr int_parse
    set pc, postamble

:built_in_int_float
    set push, a
    jsr float__to_int
    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_STR + TYPE_BOOL + TYPE_INT + TYPE_FLOAT
:built_in_float
;----------------------------------------------------------------
    jsr built_in_params

    set a, [z-1]

    ifb [a + HANDLE_TYPE], TYPE_BOOL
        set pc, built_in_float_bool
    ifb [a + HANDLE_TYPE], TYPE_STR
        set pc, built_in_float_string
    ifb [a + HANDLE_TYPE], TYPE_FLOAT
        set pc, built_in_float_float

:built_in_float_int
    set push, a
    jsr float__from_int
    set pc, postamble

:built_in_float_bool
    ife a, BOOL_FALSE
        set x, FLOAT_0
    ife a, BOOL_TRUE
        set x, FLOAT_1
    set pc, postamble

:built_in_float_string
    set push, a
    jsr float__from_str
    set pc, postamble

:built_in_float_float
    set x, a
    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_STR + TYPE_BOOL + TYPE_NONE + TYPE_INT + TYPE_FLOAT + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
:built_in_repr
;----------------------------------------------------------------
    jsr built_in_params

    jsr init_str_builder

    set push, [z-1]
    set push, built_in_repr_builder
    jsr repr

    set x, [z-2]
    set pc, postamble

:built_in_repr_builder
    set push, [repr_builder_ref]
    set push, c
    jsr array__append

    set pc, pop

:init_str_builder
    set push, 20
    set push, TYPE_STR
    jsr alloc
    set [z-2], x
    set [repr_builder_ref], x

    set pc, pop

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_hex
;----------------------------------------------------------------
    jsr built_in_params
    jsr init_str_builder

    set push, [z-1]
    set push, built_in_repr_builder
    jsr int_to_hex

    set x, [z-2]
    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_STR + TYPE_BOOL + TYPE_NONE + TYPE_INT + TYPE_FLOAT + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
:built_in_str
;----------------------------------------------------------------
    jsr built_in_params

    set x, [z-1]
    ifb [x + HANDLE_TYPE], TYPE_STR
        set pc, postamble

    jsr init_str_builder

    set push, [z-1]
    set push, built_in_repr_builder
    jsr repr

    set x, [z-2]
    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT + TYPE_BOOL + TYPE_FLOAT + TYPE_STR + TYPE_NONE + TYPE_TUPLE + TYPE_LIST + TYPE_DICT
:built_in_bool
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr boolean

    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_getchar
;----------------------------------------------------------------
    jsr built_in_params

:built_in_getchar_loop
    set a, 1              ; store next key mode
    hwi [keyboard]

    ife c, 0
        set pc, built_in_getchar_loop

    set push, 1
    set push, TYPE_STR
    jsr array_create

    set a, [x]
    set [a+1], c

    set pc, postamble

;----------------------------------------------------------------
DAT 0xffff
:built_in_key
;----------------------------------------------------------------
    jsr built_in_params
    ife i, 1
        set pc, built_in_key_1

    ifn i, 0
        jsr recover
        #doc Wrong number of arguments for key()

    set a, 1              ; store next key mode
    hwi [keyboard]

    set x, INT_0
    ife c, 0
        set pc, postamble

    set push, c
    jsr uint16_to_int

    set pc, postamble

:built_in_key_1
    set a, [z-1]
    ifb [a + HANDLE_TYPE], TYPE_INT
        set pc, built_in_key_1_int

    ifc [a + HANDLE_TYPE], TYPE_STR
        jsr recover
        #doc Wrong argument type for key(a)

    set a, [a]
    ifn [a], 1
        jsr recover
        #doc key(a) argument is string, not a char error

    set b, [a + 1]
    set pc, built_in_key_1_key

:built_in_key_1_int
    set push, a
    jsr int_to_int16
    set b, x

:built_in_key_1_key
    set a, 2              ; store next key mode
    hwi [keyboard]

    set x, BOOL_TRUE
    ife c, 0
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
DAT 0xffff
:built_in_sort
;----------------------------------------------------------------
    jsr built_in_params

    set x, NONE
    ife i, 1
        set x, BOOL_FALSE
    ife i, 2
        set x, [z-2]

    ife x, NONE
        jsr recover
        #doc sort(): Wrong number of arguments error

    ifc [x + HANDLE_TYPE], TYPE_BOOL
        jsr recover
        #doc sort(): Illegal argument type error

    set push, [z-1]
    set push, x
    jsr sort

    set pc, postamble

;----------------------------------------------------------------
DAT 0xffff
:built_in_cursor
;----------------------------------------------------------------
    jsr built_in_params
    ife i, 0
        set pc, built_in_cursor_coords
    ifn i, 2
        jsr recover
        #doc Wrong number of arguments for cursor([x, y])

    set x, [z-1]
    ifc [x + HANDLE_TYPE], TYPE_INT
        jsr recover
        #doc Illegal argument type for cursor([x, y])

    set push, x
    jsr int_to_int16

    ifb x, 0x8000
        set x, 0
    ifg x, SCREEN_COLS - 1
        set x, SCREEN_COLS - 1

    set push, x

    set x, [z-2]
    ifc [x + HANDLE_TYPE], TYPE_GROUP_INTEGER
        jsr recover
        #doc cursor(): Illegal argument type error

    set push, x
    jsr int_to_int16

    ifb x, 0x8000
        set x, 0
    ifg x, SCREEN_ROWS - 1
        set x, SCREEN_ROWS - 1

    set push, x

    jsr screen_move_cursor

:built_in_cursor_coords
    jsr screen__get_cursor

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT
:built_in_win_get
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    ifg x, SCREEN_COLS - 1
        set pc, postamble_none
    set push, x

    set push, [z-2]
    jsr int_to_int16
    ifg x, SCREEN_ROWS - 1
        set pc, postamble_none
    set push, x

    jsr screen__get
    set c, x

    set push, 1
    set push, TYPE_STR
    jsr array_create

    set a, [x]
    set [a+1], c

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT, TYPE_STR
:built_in_win_set
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    ifg x, SCREEN_COLS - 1
        set pc, postamble_none
    set push, x

    set push, [z-2]
    jsr int_to_int16
    ifg x, SCREEN_ROWS - 1
        set pc, postamble_none
    set push, x

    set x, [z-3]
    set x, [x]
    ifn [x], 1
        jsr recover
        #doc winset(): Argument string too long error

    set push, [x+1]

    jsr screen__set

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_call
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16

    set push, z
    set push, x

    jsr load_registers

    jsr pop

    jsr save_registers

    set z, pop
    set pc, postamble_none

;----------------------------------------------------------------
DAT 0xffff  ; disable parameter checks
:built_in_peek
;----------------------------------------------------------------
    jsr built_in_params

    set x, [z-1]
    ifc [x + HANDLE_TYPE], TYPE_INT
        jsr recover
        #doc peek(): Illegal argument type error

    set push, x
    jsr int_to_int16

    ife i, 2
        set pc, built_in_peek_str

    ifn i, 1
        jsr recover
        #doc peek(): Wrong number of arguments error

    set push, [x]
    jsr uint16_to_int

    set pc, postamble

:built_in_peek_str
    ; x: UINT16 *from
    set i, x

    set x, [z-2]
    ifc [x + HANDLE_TYPE], TYPE_INT
        jsr recover
        #doc peek(): Illegal argument type error

    set push, x
    jsr int_to_int16
    add i, x
    sub i, 1

    set push, x
    set push, TYPE_STR
    jsr array_create
    set j, [x]
    add j, [j]

:built_in_peek_str_loop
    ife j, [x]
        set pc, postamble

    std [j], [i]
    set pc, built_in_peek_str_loop

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT + TYPE_STR
:built_in_poke
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    set j, x

    set x, [z-2]
    ifb [x + HANDLE_TYPE], TYPE_STR
        set pc, built_in_poke_str

    set push, x
    jsr int_to_int16
    set [j], x

    set pc, postamble_none

:built_in_poke_str
    set i, [x]
    add j, [i]
    sub j, 1
    add i, [i]

:built_in_poke_str_loop
    ife i, [x]
        set pc, postamble_none

    std [j], [i]
    set pc, built_in_poke_str_loop

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_read
;----------------------------------------------------------------
    jsr built_in_params

    ife [floppy], 0xffff
        jsr recover
        #doc read(): M35FD device not present error

    set push, [z-1]
    jsr int_to_int16

    set push, x
    jsr floppy__sector__read

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_write
;----------------------------------------------------------------
    jsr built_in_params

    ife [floppy], 0xffff
        jsr recover
        #doc write(): M35FD device not present error

    set push, [z-1]
    jsr int_to_int16

    set push, x
    jsr floppy__sector__write

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0xffff  ; disable parameter validation
:built_in_hsel
;----------------------------------------------------------------
    jsr built_in_params

    ife [hic], 0xffff
        jsr recover
        #doc hsel(): HIC device not present error

    ife i, 1
        set pc, built_in_hsel_port

    ifn i, 0
        jsr recover
        #doc hsel(): Wrong number of arguments error

    set a, 0
    set c, 0
    hwi [hic]

    ife c, 0xffff
        set pc, built_in_hsel_no_data

    set push, c
    jsr uint16_to_int
    set pc, postamble

:built_in_hsel_no_data
    set x, INT_N1
    set pc, postamble

:built_in_hsel_port
    set x, [z-1]
    ifc [x + HANDLE_TYPE], TYPE_INT
        jsr recover
        #doc hsel(): Illegal argument type error

    set push, x
    jsr int_to_int16
    set c, x

    set a, 0
    hwi [hic]

    set x, BOOL_FALSE
    ifb a, 0x0004
        set x, BOOL_TRUE

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT
:built_in_rconf
;----------------------------------------------------------------
    jsr built_in_params

    ife [rci], 0xffff
        jsr recover
        #doc rconf(): RCI device not present error

    set push, [z-1]
    jsr int_to_int16
    set b, x

    set push, [z-2]
    jsr int_to_int16
    set c, x

    set a, 3
    hwi [rci]

    set x, BOOL_TRUE
    ifb c, 0x0001
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_hinfo
;----------------------------------------------------------------
    jsr built_in_params

    ife [hic], 0xffff
        jsr recover
        #doc hinfo(): HIC device not present error

    set push, [z-1]
    jsr int_to_int16
    set push, x

    set a, 0
    set c, x
    hwi [hic]

    ifb a, 0x0008
        set pc, postamble_none

    ; -------------
    ; Get port name
    ; -------------
    set push, 8
    set push, TYPE_STR
    jsr array_create
    set [z-1], x
    set b, [x]
    add b, 1

    set a, 0x0004
    set c, pop
    hwi [hic]
    ifn c, 0x0000
        jsr recover
        #doc Port number out of bounds for hinfo

:built_in_hinfo_len_loop
    ife [b], 0
        set pc, built_in_hinfo_len_finish

    add b, 1
    set pc, built_in_hinfo_len_loop

:built_in_hinfo_len_finish
    set a, [x]
    sub b, a
    set [a], b
    sub [a], 1

    set push, x
    set push, b
    jsr realloc

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_rinfo
;----------------------------------------------------------------
    jsr built_in_params

    ife [rci], 0xffff
        jsr recover
        #doc rinfo(): RCI device not present error

    ; get the info from device
    set a, 0
    hwi [rci]

    set push, a
    jsr uint16_to_int
    set [z-1], x

    set push, b
    jsr uint16_to_int
    set [z-2], x

    ; -------------
    ; Create return tuple (channel, power, antenna, device)
    ; -------------
    set push, 5
    set push, TYPE_TUPLE
    jsr array_create
    sti i, [x]

    sti [i], [z-1]
    sti [i], [z-2]

    set a, BOOL_FALSE
    ifb c, 0x0001
        set a, BOOL_TRUE
    sti [i], a

    set a, BOOL_TRUE
    ife c, 0xffe0
        set a, BOOL_FALSE
    sti [i], a

    set [i], BOOL_TRUE
    ife c, 0xfff0
        set [i], BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_hrecv
;----------------------------------------------------------------
    jsr built_in_params

    ife [hic], 0xffff
        jsr recover
        #doc hrecv(): HIC device not present error

    set push, [z-1]
    jsr int_to_int16
    set c, x

    set a, 0x0001
    hwi [hic]
    ife c, 0x0002
        jsr recover
        #doc hrecv(): HIC fail, receive error

    set x, NONE
    ife c, 0x0003
        set pc, postamble

    set push, b
    jsr uint16_to_int

    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_rrecv
;----------------------------------------------------------------
    jsr built_in_params

    ife [rci], 0xffff
        jsr recover
        #doc rrecv(): RCI device not present error

    set a, 0x0001
    set b, MEM_FLOPPY_START
    hwi [rci]

    set x, NONE
    ifn c, 0x0000
        set pc, postamble

    set push, b
    set push, TYPE_STR
    jsr array_create

    set i, MEM_FLOPPY_START
    add b, i
    set j, [x]
    add j, 1

:built_in_rrecv_loop
    ife i, b
        set pc, postamble

    set [j], [i]
    sti pc, built_in_rrecv_loop

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT
:built_in_hsend
;----------------------------------------------------------------
    jsr built_in_params

    ife [hic], 0xffff
        jsr recover
        #doc hsend(): HIC device not present error

    set push, [z-1]
    jsr int_to_int16
    set c, x

    set push, [z-2]
    jsr int_to_int16
    set b, x

    set a, 0x0002
    hwi [hic]
    ifg c, 0x0001
        jsr recover
        #doc hsend(): Transmit buffer overflow, port is not connected or HIC is busy error

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_STR
:built_in_rsend
;----------------------------------------------------------------
    jsr built_in_params

    ife [rci], 0xffff
        jsr recover
        #doc rsend(): RCI device not present error

    set a, 2
    set b, [z-1]
    set b, [b]
    set c, [b]
    add b, 1
    hwi [rci]

    set x, BOOL_TRUE
    ifn c, 0
        set x, BOOL_FALSE

    set pc, postamble

;----------------------------------------------------------------
DAT 0
:built_in_hwn
;----------------------------------------------------------------
    jsr built_in_params

    hwn x

    set push, x
    jsr uint16_to_int

    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_hwi
;----------------------------------------------------------------
    jsr built_in_params

    set push, z

    ; push first parameter value to stack
    set push, [z-1]
    jsr int_to_int16
    set push, x

    jsr load_registers

    hwi pop

    jsr save_registers
    set z, pop

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_hwq
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    hwq x

    set push, x
    set push, y
    set push, c
    set push, a
    set push, b

    set push, 3
    set push, TYPE_TUPLE
    jsr array_create
    set [z-1], x
    set a, x

    ; pop a
    jsr uint16_to_int
    set [z-2], x

    set push, x
    set push, INT_16
    jsr int_lshift

    ; pop b
    set a, [x]
    add a, [a]
    set [a], pop

    ; int to tuple
    set a, [z-1]
    set a, [a]
    set [a+1], x

    ; pop c
    jsr uint16_to_int
    set a, [z-1]
    set a, [a]
    set [a+2], x

    ; pop x
    jsr uint16_to_int
    set [z-2], x

    set push, x
    set push, INT_16
    jsr int_lshift

    ; pop y
    set a, [x]
    add a, [a]
    set [a], pop

    ; int to tuple
    set a, [z-1]
    set a, [a]
    set [a+3], x

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_GROUP_INTEGER, TYPE_GROUP_INTEGER
:built_in_scroll
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    set push, x

    set push, [z-2]
    jsr int_to_int16
    set push, x

    jsr screen__scroll

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_INT
:built_in_sleep
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
        jsr int_to_int16

    :built_in_sleep__loop
        ife x, 0
            set pc, postamble_none

        set i, 18
        :built_in_sleep__sec_loop
            ifn i, 0
                std pc, built_in_sleep__sec_loop

        sub x, 1
        set pc, built_in_sleep__loop

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0
:built_in_time
;----------------------------------------------------------------
    jsr built_in_params

    ife [timer], 0xffff
        jsr recover
        #doc time(): Timer device not present error

    set push, 7
    set push, TYPE_TUPLE
    jsr array_create
    set [z-1], x
    set j, [x]
    add j, [j]

    ; store fp
    set i, z

    set a, 0x10
    hwi [timer]

    set push, b ; year
    set push, c ; month
    shr [sp], 8
    set push, c ; day
    and [sp], 0xff
    set push, x ; hours
    shr [sp], 8
    set push, x ; minutes
    and [sp], 0xff
    set push, y ; secs
    set push, z ; ms

    ; restore fp
    set z, i

    ; ms
    jsr uint16_to_int
    std [j], x

    ; secs
    jsr uint16_to_int
    std [j], x

    ; minutes
    jsr uint16_to_int
    std [j], x

    ; hours
    jsr uint16_to_int
    std [j], x

    ; days
    jsr uint16_to_int
    std [j], x

    ; months
    jsr uint16_to_int
    std [j], x

    ; years
    jsr uint16_to_int
    std [j], x

    set x, [z-1]
    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_BOOL
:built_in_hires
;----------------------------------------------------------------
    jsr built_in_params

    ife [z-1], BOOL_TRUE
        jsr hires__init
    ife [z-1], BOOL_FALSE
        jsr hires__finish

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT
:built_in_show
;----------------------------------------------------------------
    jsr built_in_params

    ife [floppy], 0xffff
        jsr recover
        #doc show(): M35FD device not present error

    ; addr
    set push, [z-1]
    ; sector
    set push, [z-2]

    jsr hires__load_lem_from_sector

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT, TYPE_BOOL
:built_in_plot
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    ifg x, 63
        set pc, postamble_none
    set push, x

    set push, [z-2]
    jsr int_to_int16
    ifg x, 47
        set pc, postamble_none
    set push, x

    set push, 0x0
    ife BOOL_TRUE, [z-3]
        set [sp], 0xf

    jsr hires__point

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT
:built_in_point
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    ifg x, 63
        set pc, BOOL_FALSE
    set push, x

    set push, [z-2]
    jsr int_to_int16
    ifg x, 47
        set pc, BOOL_FALSE
    set push, x

    jsr hires__get_point
    set pc, postamble

:built_in_point_false
    set x, BOOL_FALSE
    set pc, postamble

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT, TYPE_INT, TYPE_BOOL
:built_in_circle
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    ifg x, 63
        set pc, postamble_none
    set push, x

    set push, [z-2]
    jsr int_to_int16
    ifg x, 47
        set pc, postamble_none
    set push, x

    set push, [z-3]
    jsr int_to_int16
    ifg x, 63
        set pc, postamble_none
    set push, x

    set push, 0x0
    ife BOOL_TRUE, [z-4]
        set [sp], 0xf

    jsr hires__circle

    set pc, postamble_none

;----------------------------------------------------------------
DAT 0, TYPE_INT, TYPE_INT, TYPE_INT, TYPE_INT, TYPE_BOOL
:built_in_line
;----------------------------------------------------------------
    jsr built_in_params

    set push, [z-1]
    jsr int_to_int16
    ifg x, 63
        set pc, postamble_none
    set push, x

    set push, [z-2]
    jsr int_to_int16
    ifg x, 47
        set pc, postamble_none
    set push, x

    set push, [z-3]
    jsr int_to_int16
    ifg x, 63
        set pc, postamble_none
    set push, x

    set push, [z-4]
    jsr int_to_int16
    ifg x, 47
        set pc, postamble_none
    set push, x

    set push, 0x0
    ife BOOL_TRUE, [z-5]
        set [sp], 0xf

    jsr hires__line

    set pc, postamble_none

;;----------------------------------------------------------------
;DAT 0, TYPE_INT, TYPE_INT, TYPE_INT, TYPE_INT
;:built_in_color
;;----------------------------------------------------------------
;    jsr built_in_params
;
;    set push, [z-1]
;    jsr int_to_int16
;    set push, x
;
;    set push, [z-2]
;    jsr int_to_int16
;    set push, x
;
;    set push, [z-3]
;    jsr int_to_int16
;    set push, x
;
;    set push, [z-4]
;    jsr int_to_int16
;    set push, x
;
;    jsr screen__color
;
;    set pc, postamble_none

;----------------------------------------------------------------
:built_in_params
; util function used by built-in impls to parse arguments
;----------------------------------------------------------------
    set i, 0    ; param counter

:built_in_params_loop
    jsr lexer_next    ; skip '(' or ','

    ife i, 5
        set pc, built_in_params_end
    ife [lexer_token], token_rparen
        set pc, built_in_params_end

    set push, 0x0030
    jsr expression

    sti a, z
    sub a, i
    set [a], x

    set push, x
    jsr eval
    set [a], x


    ife [lexer_token], token_comma
        set pc, built_in_params_loop

:built_in_params_end
    set push, token_rparen
    jsr lexer_advance    ; skip ')'

    set a, [sp]
    sub a, 3
    ife [a], 0xffff
        ; disable parameter checking
        set pc, pop

    set b, z
    sub b, i

:built_in_params_type_loop
    ife [a], 0
        set pc, built_in_params_type_end

    set x, [b]
    ifc [a], [x + HANDLE_TYPE]
        jsr recover
        #doc Type mismatch error

    sub a, 1
    add b, 1
    set pc, built_in_params_type_loop

:built_in_params_type_end
    ife b, z
        set pc, pop
    jsr recover
    #doc Illegal parameter list error

;----------------------------------------------------------------
:load_registers
; fastcall
;----------------------------------------------------------------
    set a, [REGISTER_A]
    set b, [REGISTER_B]
    set c, [REGISTER_C]
    set x, [REGISTER_X]
    set y, [REGISTER_Y]
    set z, [REGISTER_Z]
    set i, [REGISTER_I]
    set j, [REGISTER_J]
    set pc, pop

;----------------------------------------------------------------
:save_registers
; fastcall
;----------------------------------------------------------------
    set [REGISTER_A], a
    set [REGISTER_B], b
    set [REGISTER_C], c
    set [REGISTER_X], x
    set [REGISTER_Y], y
    set [REGISTER_Z], z
    set [REGISTER_I], i
    set [REGISTER_J], j
    set pc, pop
