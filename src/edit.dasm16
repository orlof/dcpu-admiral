;----------------------------------------------------------------
; extern struct handle *edit_main(struct handle *str)
:edit_main
;----------------------------------------------------------------
	set push, 1
	set push, 1
	jsr preamble

	; initialize cursor to top left corner
	; these are screen coordinates (not column or line in text) as 
	; screen scrolls in both axis
	set [cur_x], 0
	set [cur_y], 0

	; prev_char is a hack used to test with continuous cursor
	; movement while keeping button down - no luck
	set [prev_char], 0

	; initialize next screen
	jsr screen_next
	jsr screen_clear

	; reserve space for editing text as string (not _really_ correct)
	set push, EDIT_BUFFER_SIZE
	set push, TYPE_STR
	jsr alloc
	set [z-1], x

	set x, [x]			; x: struct string *

	set [buf_start], x
	set [gap_start], x
	set [cur_pos], x
	set [win_start], x
	set [cur_line], x

	add x, EDIT_BUFFER_SIZE
	set [buf_end], x
	set [gap_end], x

	set x, [z+10]
	set x, [x]
	set y, x
	add y, 1
	add x, [x]

:edit_copy_arg_to_buffer
	ifg y, x
		set pc, edit_main_loop

	set c, [y]
	jsr edit_insert_char
	add y, 1
	set pc, edit_copy_arg_to_buffer

:edit_main_loop	
	jsr win_normalize
	jsr edit_win_draw

	set push, [cur_x]
	set push, [cur_y]
	jsr screen_move_cursor

	set c, [prev_char]

	jsr screen_toggle_cursor
	jsr win_getchar
	jsr screen_toggle_cursor

	set [prev_char], c

	ife c, KEY_UP
		set pc, edit_key_up
	ife c, KEY_DOWN
		set pc, edit_key_down
	ife c, KEY_LEFT
		set pc, edit_key_left
	ife c, KEY_RIGHT
		set pc, edit_key_right
	ife c, KEY_DEL
		set pc, edit_key_del
	ife c, KEY_BS
		set pc, edit_key_bs
	ife c, KEY_NEWLINE
		set pc, edit_key_newline
	ife c, KEY_CTRL_X
		set pc, edit_main_finish
	ife c, KEY_CTRL_C
		set pc, edit_main_finish
	ifg c, 0x19
		ifl c, 0x7f
			set pc, edit_key_character

	set pc, edit_main_loop

:edit_main_finish
	jsr screen_prev

	set x, [z+10]
	ife c, KEY_CTRL_C
		set pc, postamble

	set c, [buf_end]
	sub c, [buf_start]
	add c, [gap_start]
	sub c, [gap_end]
	
	set push, c
	set push, TYPE_STR
	jsr array_create

	sti j, [x]	
	set i, [buf_start]

:edit_copy_buffer_to_result
	ife i, [gap_start]
		set i, [gap_end]
	ife i, [buf_end]
		set pc, postamble	
	sti [j], [i]
	set pc, edit_copy_buffer_to_result

;----------------------------------------------------------------
:edit_key_up
;----------------------------------------------------------------
	set a, [cur_line]
	jsr prevline
	set [cur_line], a
	
	set b, [cur_x]
	add b, [win_shift]
	jsr pos_x
	set [cur_pos], a
	
	set pc, edit_main_loop

	; void k_up (void) {
	;	cur_line = prevline (cur_line);
	;	cur_pos = pos_x (cur_line, cur_x + win_shift);
	; }

;----------------------------------------------------------------
:edit_key_down
;----------------------------------------------------------------
	set a, [cur_pos]
	jsr eol
	ife a, [buf_end]
		set pc, edit_main_loop

	set a, [cur_line]
	jsr nextline
	set [cur_line], a
	
	set b, [cur_x]
	add b, [win_shift]
	jsr pos_x
	set [cur_pos], a
	
	set pc, edit_main_loop

	; void k_down (void) {
	;	if (eol (cur_pos) < eof_pos) {
	;		cur_line = nextline (cur_line);
	;		cur_pos = pos_x (cur_line, cur_x + win_shift);
	;	}
	; }
;----------------------------------------------------------------
:edit_key_left
;----------------------------------------------------------------
	ife [cur_pos], [gap_end]
		set [cur_pos], [gap_start]
	ifg [cur_pos], [buf_start]
		sub [cur_pos], 1
	set pc, edit_main_loop
;----------------------------------------------------------------
:edit_key_right
;----------------------------------------------------------------
	ife [cur_pos], [gap_start]
		set [cur_pos], [gap_end]
	ifl [cur_pos], [buf_end]
		add [cur_pos], 1
	ife [cur_pos], [gap_start]
		set [cur_pos], [gap_end]
	set pc, edit_main_loop
;----------------------------------------------------------------
:edit_key_del
;----------------------------------------------------------------
	ifl [cur_pos], [buf_end]
		jsr edit_remove_char
	set pc, edit_main_loop
;----------------------------------------------------------------
:edit_key_bs
;----------------------------------------------------------------
	ife [cur_pos], [gap_end]
		set [cur_pos], [gap_start]
	ife [cur_pos], [buf_start]
		set pc, edit_main_loop
	sub [cur_pos], 1
	jsr edit_remove_char
	set pc, edit_main_loop
;----------------------------------------------------------------
;:edit_key_newline
:edit_key_character
;----------------------------------------------------------------
	jsr edit_insert_char
	
	; void ins_ch (char ch) {
	;	if (ins_mem (1))
	;		text[cur_pos++] = ch;
	; }

	set pc, edit_main_loop

:edit_key_newline
	jsr edit_insert_char

	set b, [cur_line]	
	set c, ' '
:edit_key_newline_loop
	ifn [b], c
		set pc, edit_main_loop
	jsr edit_insert_char
	add b, 1
	set pc, edit_key_newline_loop

;----------------------------------------------------------------
:edit_win_draw
;----------------------------------------------------------------	
	set a, [current_screen]
	set i, [win_start]
	set j, [a + SCREEN__START]

:edit_win_draw_loop
	jsr edit_line_draw

	ifl j, [a + SCREEN__END]
		set pc, edit_win_draw_loop

	set pc, pop
;----------------------------------------------------------------
:edit_line_draw
; fastcall
;   i: buffer pointer to beginning of line
;   j: screen pointer to beginning of line
; return
;   i: pointer to beginning of next line in buffer or buf_end
;   j: pointer to beginning of next line in window of SCREEN_END
;----------------------------------------------------------------
	set c, 0
:edit_line_skip_start
	ife i, [gap_start]
		set i, [gap_end]
	ife c, [win_shift]
		set pc, edit_line_chars
	ife i, [buf_end]
		set pc, edit_line_chars
	ife [i], KEY_NEWLINE
		set pc, edit_line_chars

	add i, 1
	add c, 1

	set pc, edit_line_skip_start
	
:edit_line_chars
	set c, j
	add c, SCREEN_COLS

:edit_line_chars_loop
	set [j], 0
	ife i, [buf_end]
		set pc, edit_line_chars_loop_1
	ife [i], KEY_NEWLINE
		set pc, edit_line_chars_loop_1

	set [j], [i]
	bor [j], FONT_COLOR

	
	add i, 1
	ife i, [gap_start]
		set i, [gap_end]
	
:edit_line_chars_loop_1
	add j, 1
	ifl j, c
		set pc, edit_line_chars_loop

	set c, edit_line_skip_end
:edit_line_skip_end
	ife i, [buf_end]
		set pc, pop
	ife [i], KEY_NEWLINE
		set c, pop

	add i, 1
	ife i, [gap_start]
		set i, [gap_end]
		
	set pc, c

;----------------------------------------------------------------
:edit_gap_move
;----------------------------------------------------------------
	set i, [gap_start]
	set j, [gap_end]
	
:edit_gap_move_loop
	ifl j, [cur_pos]
		sti [i], [j]
	ifg i, [cur_pos]
		std [j-1], [i-1]
	ifn i, [cur_pos]
		ifn j, [cur_pos]
			set pc, edit_gap_move_loop

	set [gap_start], i
	set [gap_end], j

	set [cur_pos], j
	set pc, pop

;----------------------------------------------------------------
:edit_insert_char
;----------------------------------------------------------------
	ife [gap_start], [gap_end]
		set pc, pop

	jsr edit_gap_move	

	set a, [gap_start]
	set [a], c
	add [gap_start], 1
	set pc, pop

;----------------------------------------------------------------
:edit_remove_char
;----------------------------------------------------------------
	ife [cur_pos], [buf_end]
		set pc, pop
	ife [gap_start], [buf_start]
		ife [gap_end], [buf_end]
			set pc, pop

	jsr edit_gap_move	

	add [gap_end], 1
	add [cur_pos], 1
	set pc, pop
;----------------------------------------------------------------
:bol
; fastcall
; 	a: pos
; return
;   a: beginning of line pointer
;----------------------------------------------------------------
	ife a, [gap_end]
		set a, [gap_start]

	ife a, [buf_start]
		set pc, pop
		
	sub a, 1
	
	ifn [a], KEY_NEWLINE
		set pc, bol		

	add a, 1
	ife a, [gap_start]
		set a, [gap_end]

	set pc, pop	

	; int bol (int pos) {
	;	while (pos && text[pos - 1] != '\n')
	;		pos--;
	;	return pos;
	; }
;----------------------------------------------------------------
:eol
; fastcall
; 	a: pos
; return
;   a: pointer to next newline or buf_end
;----------------------------------------------------------------
	ife a, [gap_start]
		set a, [gap_end]

	ife a, [buf_end]
		set pc, pop

	ife [a], KEY_NEWLINE
		set pc, pop		

	add a, 1
	ife a, [gap_start]
		set a, [gap_end]

	set pc, eol

	; int eol (int pos) {
	;	while (pos < eof_pos && text[pos] != '\n')
	;		pos++;
	;	return pos;
	; }
;----------------------------------------------------------------
:prevline
; fastcall
; 	a: pos
; return
;   a: beginning of previous line
;----------------------------------------------------------------
	jsr bol
	ife a, [buf_start]
		set pc, pop

	ife a, [gap_end]
		set a, [gap_start]
	sub a, 1
		
	jsr bol
	set pc, pop

	; int prevline (int pos) {
	;	pos = bol (pos);
	;	return pos ? bol (pos - 1) : 0;
	; }

;----------------------------------------------------------------
:nextline
; fastcall
; 	a: pos
; return
;   a: beginning of next line
;----------------------------------------------------------------
	jsr eol
	ifl a, [buf_end]
		add a, 1

	ife a, [gap_start]
		set a, [gap_end]

	set pc, pop

	; int nextline (int pos) {
	;	pos = eol (pos);
	;	return pos < eof_pos ? pos + 1 : pos;
	; }

;----------------------------------------------------------------
:pos_x
; convert column to pointer
; fastcall
;   a: line beginning pointer
;   b: column
; return
;   a: pointer to char in buf 
;----------------------------------------------------------------
	ife b, 0
		set pc, pop
	ife a, [buf_end]
		set pc, pop
	ife [a], KEY_NEWLINE
		set pc, pop

	sub b, 1
	add a, 1
	ife a, [gap_start]
		set a, [gap_end]
		
	set pc, pos_x

	; int pos_x (int line, int xx) {
	;	int	i, x = 0;
	;
	;	for (i = line; i < eof_pos && x < xx; i++)
	;		if (text[i] == '\n')
	;			break;
	;		else
	;			x++;
	;	return i;
	; }







;----------------------------------------------------------------
:win_x
; fastcall
;   a: line beginning pointer
;   b: pointer to char in buf
; return
;   c: column
;----------------------------------------------------------------
	set c, 0

	ife a, b
		set pc, pop
:win_x_loop
	ife a, [gap_start]
		set a, [gap_end]

	ife a, b
		set pc, pop

	add c, 1
	add a, 1

	set pc, win_x_loop

	; int win_x (int line, int xx) {
	;	int	i, x = 0;
	;	for (i = line; i < eof_pos && i < line + xx; i++)
	;		if (text[i] == '\n')
	;			break;
	;		else
	;			x++;
	;	return x;
	; }




:win_normalize
	; cur_line = bol (cur_pos);
	set a, [cur_pos]
	jsr bol
	set [cur_line], a

	; while (cur_line < bow_line)
	;	bow_line = prevline (bow_line);
:win_normalize_2
	ife [cur_line], [win_start]
		set pc, win_normalize_1
	ifg [cur_line], [win_start]
		set pc, win_normalize_1
	
	set a, [win_start]
	jsr prevline
	set [win_start], a

	set pc, win_normalize_2

:win_normalize_1
	; cur_y = 0;
	set [cur_y], 0

	; for (i = bow_line; i < cur_line; i = nextline (i))
	;	cur_y++;

	set a, [win_start]				; i = bow_line
:win_normalize_4
	ife a, [cur_line]				; i < cur_line
		set pc, win_normalize_3

	jsr nextline					; i = nextline(i)

	add [cur_y], 1					; cur_y++
	
	set pc, win_normalize_4

	; for (; cur_y >= LINES; cur_y--)
:win_normalize_3
	set a, [win_start]

:win_normalize_6
	ifl [cur_y], SCREEN_ROWS				; cur_y >= LINES
		set pc, win_normalize_5

	; bow_line = nextline (bow_line);
	jsr nextline					

	sub [cur_y], 1					; cur_y--
	set pc, win_normalize_6

:win_normalize_5
	set [win_start], a		
;---
	set a, [cur_line]
	set b, [cur_pos]
	jsr win_x
	sub c, [win_shift]
	set [cur_x], c
	
:win_normalize_8
	ifc [cur_x], 0x8000
		set pc, win_normalize_7
			
	add [cur_x], 8
	sub [win_shift], 8
	
	set pc, win_normalize_8
	
:win_normalize_7
	ifl [cur_x], SCREEN_COLS
		set pc, pop
	
	sub [cur_x], 8
	add [win_shift], 8
	
	set pc, win_normalize_7
