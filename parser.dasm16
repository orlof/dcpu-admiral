;----------------------------------------------------------------
:parser_stmt
; main method to parse anything
;----------------------------------------------------------------
	set push, 0
	set push, 4
	jsr preamble

	set y, [lexer_token]
	set pc, [y + PROTOTYPE_STD]

;----------------------------------------------------------------
:parser_simple_stmt
; e.g. print hi is simple stmt
;   if true: print "Hi"
;----------------------------------------------------------------
	set push, 0
	set push, 1
	jsr preamble

	; compound stmts are not allowed here
	;   if true: if true: print "Hi"
	; that would make parsing more complex
	set c, [lexer_token]
	ife c, token_while
		jsr recover
	ife c, token_if
		jsr recover
	ife c, token_for
		jsr recover

	set y, [lexer_token]
	set pc, [y + PROTOTYPE_STD]

;----------------------------------------------------------------
:std_newline
; return struct handle *none
;----------------------------------------------------------------
	jsr lexer_next

;----------------------------------------------------------------
:std_eof
; return struct handle *none
;----------------------------------------------------------------
	set x, NONE
	set pc, postamble

;----------------------------------------------------------------
:std_indent
:std_dedent
; return struct handle *none
;----------------------------------------------------------------
	jsr recover

;----------------------------------------------------------------
:std_cls
; clear lem
; return struct handle *none
;----------------------------------------------------------------
	jsr lexer_next		; skip 'cls'

	jsr screen_clear

	set x, NONE
	set pc, postamble

;----------------------------------------------------------------
:std_reset
; restart admiral
;----------------------------------------------------------------
	jsr screen_clear
	set sp, 0
	set z, 0
	set pc, interpreter_main

;----------------------------------------------------------------
:std_print	
; return struct handle *none
;----------------------------------------------------------------
	jsr lexer_next		; skip 'print'

:std_print_loop
	ife [lexer_token], token_newline
		set pc, std_print_break_newline
	ife [lexer_token], token_eof
		set pc, std_print_break_eof

	set push, 0
	jsr expression
    set [z-1], x

	ife [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
		set pc, std_print_array
		
	set push, x
	jsr eval
    set [z-1], x

	set push, x
	jsr print
	
	set pc, std_print_loop

:std_print_array
	set push, x
	jsr eval
    set [z-1], x

	set push, x

	set push, std_print_iterator
	jsr array_map

	set pc, std_print_loop

:std_print_iterator
	set push, c
	set push, [sp+2]
	jsr print

	set c, ' '
	jsr screen_add_char

	set c, pop
	set [sp], pop
	set pc, pop

:std_print_break_newline
	set push, token_newline
	jsr lexer_advance

:std_print_break_eof
	set c, 10
	jsr screen_add_char

	set x, NONE
	set pc, postamble

;----------------------------------------------------------------
:std_return
; return struct handle *control
;----------------------------------------------------------------
	jsr lexer_next		; skip return

	set push, SIZEOF_CONTROL				; create struct control
	set push, TYPE_CONTROL
	jsr array_create
    set [z-1], x

	set a, [x]
	set [a + CONTROL_SIGNAL], token_return		; set control type
	set [a + CONTROL_VALUE], NONE			; default: no return value

	ife [lexer_token], token_newline
		set pc, std_return_finish
	
	set push, 0
	jsr expression

    set a, [z-1]
	set a, [a]
	set [a + CONTROL_VALUE], x

:std_return_finish
	; keeping lexer up to date is not needed after return
	; set push, token_newline
	; jsr lexer_advance

    set x, [z-1]
	set pc, postamble
	
;----------------------------------------------------------------
:std_break
:std_continue
; return struct handle *control
;----------------------------------------------------------------
	set b, [lexer_token]		; store token for control signal

	jsr lexer_next			; advance 'break'

	set push, token_newline		; verify newline
	jsr lexer_advance

	set push, SIZEOF_CONTROL			; create struct control
	set push, TYPE_CONTROL
	jsr array_create

	set a, [x]
	set [a + CONTROL_SIGNAL], b 	; set control signal
	set [a + CONTROL_VALUE], NONE	; default: no return value
	set pc, postamble

;----------------------------------------------------------------
:std_pass
; return struct handle *none
;----------------------------------------------------------------
	jsr lexer_next

	set push, token_newline
	jsr lexer_advance

	set x, NONE
	set pc, postamble

;----------------------------------------------------------------
:std_for
; for x in list:
;  print x
; return struct handle *none
; todo implement else
; problems: stupid python grammar has valid token (in) as for loop
; separator. there is no way for parser to detect between expression 
; operator and for separator.
;----------------------------------------------------------------
	jsr lexer_next		; advance 'for'
	jsr parser_fork_scope

	; get the testlist (left side)
	set push, 0x0000
	jsr testlist
    set [z-3], x

	set push, token_in	; verify 'in'
	jsr lexer_advance
	
	; get the exprlist (right side)
	set push, 0x0000
	jsr expression
    set [z-4], x

	set push, x
	jsr eval
    set [z-4], x

	set push, token_colon		; verify colon
	jsr lexer_advance
	
	jsr lexer_store				; store lexer position

	set i, 0
	
:std_for_loop
    set a, [z-3]   ; struct handle *left
    set b, [z-4]   ; struct handle *right

	set c, [b]		; struct data *right
	ife i, [c]		; i == rightLen -> done
		set pc, std_for_finish

	add c, i		; c+1 = points to current item
	ife [b + HANDLE_TYPE], TYPE_STRING
		set pc, std_for_loop_string
		
	set push, a
	set push, [c+1]
	jsr assign

:std_for_execute_suite
	jsr parser_suite
	ife [x + HANDLE_TYPE], TYPE_CONTROL
		set pc, std_for_control
;	ife [lexer_token], token_eof
;		set pc, std_for_eof

:std_for_control_continue
	jsr lexer_restore				; restore lexer to loop condition
	sti pc, std_for_loop

:std_for_loop_string
	ife [a + HANDLE_TYPE], TYPE_TUPLE
		set pc, std_for_loop_string_tuple

	set push, a
	set push, [c+1]
	jsr assign_from_string

	set pc, std_for_execute_suite

:std_for_loop_string_tuple
	set push, a
	set push, b
	jsr assign
	
	set pc, std_for_execute_suite

:std_for_control
	set a, [x]
	ife [a + CONTROL_SIGNAL], token_continue
		set pc, std_for_control_continue
	ife [a + CONTROL_SIGNAL], token_break
		set pc, std_for_control_break
	ife [a + CONTROL_SIGNAL], token_return
		set pc, std_for_control_return

	jsr recover

:std_for_control_break
	jsr lexer_restore

:std_for_finish	
	jsr parser_skip_suite
:std_for_eof
	set x, NONE

:std_for_control_return
    set [current_scope], [z-1]
	set pc, postamble

;----------------------------------------------------------------
:std_del
;----------------------------------------------------------------
	jsr lexer_next			; advance 'del'

:std_del_loop
	ife [lexer_token], token_newline
		set pc, std_del_break

	set push, 0
	jsr expression
    set [z-1], x
	
	set push, x
	jsr del
	
	set pc, std_del_loop

:std_del_break
	set x, NONE
	set pc, postamble

;----------------------------------------------------------------
:std_if
; return struct handle *none
;----------------------------------------------------------------
	jsr lexer_next			; advance 'if'

	set push, 0			; evaluate if condition
	jsr expression
    set [z-3], x
	
	set push, x
	jsr eval
    set [z-3], x
	
	set push, token_colon		; verify colon
	jsr lexer_advance

    ife [z-3], BOOL_HANDLE_FALSE   ; break if loop condition is false
		set pc, std_if_false

	jsr parser_suite
	ife [x + HANDLE_TYPE], TYPE_CONTROL
		set pc, postamble
	ife [lexer_token], token_eof
		set pc, std_if_eof

	set pc, std_if_skip

:std_if_skip_loop
	set push, token_colon
	jsr parser_skip_until_token

	jsr lexer_next			; skip COLON

	jsr parser_skip_suite
	ife [lexer_token], token_eof
		set pc, std_if_eof

:std_if_skip
	ife [lexer_token], token_elif
		set pc, std_if_skip_loop
	ife [lexer_token], token_else
		set pc, std_if_skip_loop

	set pc, std_if_eof

:std_if_false
	jsr parser_skip_suite
	ife [lexer_token], token_elif
		set pc, std_if
	ife [lexer_token], token_else
		set pc, std_if_else
	
	set pc, std_if_eof

:std_if_else
	jsr lexer_next		; skip else

	set push, token_colon
	jsr lexer_advance	; skip COLON
	
	jsr parser_suite

	ife [x + HANDLE_TYPE], TYPE_CONTROL
		set pc, postamble

:std_if_eof
	set x, NONE
	set pc, postamble

;----------------------------------------------------------------
:parser_fork_scope
;----------------------------------------------------------------
    set [z-1], [current_scope] ; store current scope

	;----------------------------------------------------------------
	; comment to disabled block scope to mimic python's deficiencies
	set push, 5			; create new scope for while block
	set push, TYPE_DICT
	jsr alloc
    set [z-2], x
	set [current_scope], x		; set new scope in effect

	set push, x			; set parent scope
	set push, STR_UNDERSCORE
    set push, [z-1]
	jsr dict__set
	;----------------------------------------------------------------

	set pc, pop

;----------------------------------------------------------------
:std_while
; return struct handle *none
; todo implement else
;----------------------------------------------------------------
	jsr lexer_next				; advance 'while'

	jsr parser_fork_scope

	jsr lexer_store				; store lexer position

:std_while_loop
	set push, 0					; evaluate loop condition
	jsr expression
    set [z-3], x
	
	set push, token_colon		; verify colon
	jsr lexer_advance

    ife [z-3], BOOL_HANDLE_FALSE   ; break if loop condition is false
		set pc, std_while_false

	jsr parser_suite
	ife [x + HANDLE_TYPE], TYPE_CONTROL
		set pc, std_while_control
;	ife [lexer_token], token_eof
;		set pc, std_while_eof	

:std_while_control_continue
	jsr lexer_restore				; restore lexer to loop condition
	set pc, std_while_loop

:std_while_control
	set a, [x]
	ife [a + CONTROL_SIGNAL], token_continue
		set pc, std_while_control_continue
	ife [a + CONTROL_SIGNAL], token_break
		set pc, std_while_control_break
	ife [a + CONTROL_SIGNAL], token_return
		set pc, std_while_control_return

	jsr recover

:std_while_control_break
	jsr lexer_restore
	
	set push, token_colon
	jsr parser_skip_until_token

	jsr lexer_next		; skip colon

:std_while_false
	jsr parser_skip_suite
:std_while_eof
	set x, NONE

:std_while_control_return
    set [current_scope], [z-1]
	set pc, postamble

;----------------------------------------------------------------
; void parser_skip_suite()
;----------------------------------------------------------------
:parser_skip_until_token
	ife [lexer_token], [sp + 1]
		set pc, parser_skip_until_token_finish
	ife [lexer_token], token_eof
		set pc, parser_skip_until_token_finish

	jsr lexer_next
	set pc, parser_skip_until_token

:parser_skip_until_token_finish
	set [sp], pop
	set pc, pop

;----------------------------------------------------------------
; void parser_skip_suite()
;----------------------------------------------------------------
:parser_skip_suite
	set push, 0
	set push, 0
	jsr preamble

	ife [lexer_token], token_newline
		jsr parser_skip_suite_block

:parser_skip_suite_simple_stmt
	set push, token_newline
	jsr parser_skip_until_token

:parser_skip_suite_simple_stmt_finish
	jsr lexer_next		; skip newline
	set pc, postamble

:parser_skip_suite_block
	jsr lexer_next		; skip newline

	set push, token_indent	; verify indent
	jsr lexer_advance

	set a, 1

:parser_skip_suite_block_loop
	ife [lexer_token], token_indent
		add a, 1
	ife [lexer_token], token_dedent
		sub a, 1		

	jsr lexer_next

	ife a, 0
		set pc, postamble

	set pc, parser_skip_suite_block_loop

;----------------------------------------------------------------
; void parser_suite()
;----------------------------------------------------------------
:parser_suite
	set push, 0
	set push, 0
	jsr preamble

	ife [lexer_token], token_newline
		set pc, parser_suite_block

:parser_suite_simple_stmt
	jsr parser_simple_stmt
	set pc, postamble

:parser_suite_block
	jsr lexer_next		; skip newline

	set push, token_indent	; verify indent
	jsr lexer_advance
	
:parser_suite_block_loop
	jsr parser_stmt
	
	ife [x + HANDLE_TYPE], TYPE_CONTROL
		set pc, postamble

	ife [lexer_token], token_dedent
		set pc, parser_suite_block_break

	ife [lexer_token], token_eof
		set pc, postamble

	set pc, parser_suite_block_loop

:parser_suite_block_break
	jsr lexer_next	; skip dedent
	set pc, postamble

;----------------------------------------------------------------
:std_expression
;----------------------------------------------------------------
	set push, 0
	jsr expression

	set pc, postamble

;----------------------------------------------------------------
; struct handle *expression(uint16 rbp)
;----------------------------------------------------------------
:expression
	set push, 1
	set push, 1			; struct handle *left
	jsr preamble

	set b, [z+10]		; rbp

	set c, [lexer_token]
	jsr [c + PROTOTYPE_NUD]
	
    set [z-1], x       ; struct handle *left

:expr_loop
	set c, [lexer_token]

	ifg b, [c + PROTOTYPE_LBP]
		set pc, expr_finish
	ife b, [c + PROTOTYPE_LBP]
		set pc, expr_finish

    set push, [z-1]
	jsr [c + PROTOTYPE_LED]
:expression_callback
	set [z-1], x		; struct handle *left

	set pc, expr_loop

:expr_finish
    set x, [z-1]       ; struct handle *left
	set pc, postamble
	
;----------------------------------------------------------------
; struct handle *testlist(uint16 rbp)
;----------------------------------------------------------------
:testlist
	set push, 1
	set push, 1			; struct handle *left
	jsr preamble

	set b, [z+10]		; rbp

	set y, 0
	ife [lexer_token], token_name
		set y, nud_name
	ife [lexer_token], token_lparen
		set y, nud_lparen

	ife y, 0
		jsr recover
		
	jsr y
    set [z-1], x       ; struct handle *left

:testlist_loop
	set c, [lexer_token]

	ifg b, [c + PROTOTYPE_LBP]
		set pc, expr_finish
	ife b, [c + PROTOTYPE_LBP]
		set pc, expr_finish

	set y, 0
	ife c, token_lbrack
		set y, led_lbrack
	ife c, token_reference
		set y, led_reference
	ife c, token_comma
		set y, led_comma
	
	ife y, 0
		set pc, expr_finish
	
    set push, [z-1]
	jsr y
:testlist_callback
    set [z-1], x       ; struct handle *left

	set pc, testlist_loop

;----------------------------------------------------------------
; struct handle *nud_int()
;----------------------------------------------------------------
:nud_int
	set push, 0
	set push, 1
	jsr preamble

	jsr lexer_get_token_as_string
    set [z-1], x

	set push, [z-1]
	jsr int_parse
    set [z-1], x
		
	jsr lexer_next

    set x, [z-1]
	set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_float()
;----------------------------------------------------------------
:nud_float
	set push, 0
	set push, 1
	jsr preamble

	jsr lexer_get_token_as_string
    set [z-1], x

	set push, [z-1]
	jsr float_from_str
    set [z-1], x
		
	jsr lexer_next

    set x, [z-1]
	set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_name()
;----------------------------------------------------------------
:nud_str
:nud_name
	set push, 0
	set push, 1
	jsr preamble

	jsr lexer_get_token_as_string
    set [z-1], x
	
	jsr lexer_next

    set x, [z-1]
	set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_none()
;----------------------------------------------------------------
:nud_none
	jsr lexer_next
	set x, NONE
	set pc, pop

;----------------------------------------------------------------
; struct handle *nud_true()
;----------------------------------------------------------------
:nud_true
	jsr lexer_next
	set x, BOOL_HANDLE_TRUE
	set pc, pop

;----------------------------------------------------------------
; struct handle *nud_false()
;----------------------------------------------------------------
:nud_false
	jsr lexer_next
	set x, BOOL_HANDLE_FALSE
	set pc, pop

;----------------------------------------------------------------
; struct handle *nud_lparen()
; expression or tuple
;----------------------------------------------------------------
:nud_lparen
	set push, 0
	set push, 1
	jsr preamble

	jsr lexer_next	; skip '('
	
	ife [lexer_token], token_rparen
		set pc, nud_lparen_empty

	set push, 0
	jsr expression
    set [z-1], x

	ifb [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
		set [x + HANDLE_TYPE], TYPE_TUPLE

	set push, token_rparen
	jsr lexer_advance

    set x, [z-1]
	set pc, postamble

:nud_lparen_empty
	jsr lexer_next	; skip ')'

	set push, 0
	set push, TYPE_TUPLE
	jsr array_create

	set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_lbrack()
; list
;----------------------------------------------------------------
:nud_lbrack
	set push, 0
	set push, 2
	jsr preamble

	jsr lexer_next	; skip '['
	
	ife [lexer_token], token_rbrack
		set pc, nud_lbrack_empty

	set push, 0
	jsr expression
    set [z-1], x

	ife [x + HANDLE_TYPE], TYPE_TUPLE_COMMA
		set pc, nud_lbrack_change_type
	
	set push, 5
	set push, TYPE_LIST
	jsr alloc
    set [z-2], x

	set a, [x]
	set	[a], 1
    set [a+1], [z-1]
	set pc, nud_lbrack_continue
	
:nud_lbrack_change_type
	set [x + HANDLE_TYPE], TYPE_LIST
    set [z-2], x

:nud_lbrack_continue
	set push, token_rbrack
	jsr lexer_advance

    set x, [z-2]
	set pc, postamble

:nud_lbrack_empty
	jsr lexer_next	; skip ']'

	set push, 5
	set push, TYPE_LIST
	jsr alloc

	set pc, postamble
;----------------------------------------------------------------
; struct handle *nud_lcurly()
; dict
;----------------------------------------------------------------
:nud_lcurly
	set push, 0
	set push, 4
	jsr preamble

	set push, 5
	set push, TYPE_DICT
	jsr alloc
    set [z-1], x

:nud_lcurly_loop
	jsr lexer_next	; skip '{' or ','

	ife [lexer_token], token_rcurly
		set pc, nud_lcurly_finish

	; left side (key)
	set push, 0
	jsr expression
    set [z-3], x

	set push, x
	jsr eval
	set [z-3], x

	set push, token_colon
	jsr lexer_advance		; skip ':'

	; right side (value)
	set push, 0x0030		; break at comma
	jsr expression
    set [z-4], x

	set push, x
	jsr eval
    set [z-4], x

	; kv-pair
	set push, 2
	set push, TYPE_TUPLE
	jsr array_create
    set [z-2], x

	set a, [x]
    set [a + DICT_ITEM_KEY],   [z-3]
    set [a + DICT_ITEM_VALUE], [z-4]

    set push, [z-1]
	set push, -1
    set push, [z-2]
	jsr array_insert

	ife [lexer_token], token_comma
		set pc, nud_lcurly_loop

:nud_lcurly_finish
	set push, token_rcurly
	jsr lexer_advance

    set x, [z-1]
	set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_plus()
;----------------------------------------------------------------
:nud_plus
	jsr lexer_next

	set push, 0x0150
	jsr expression

	set pc, pop

;----------------------------------------------------------------
; struct handle *nud_minus()
;----------------------------------------------------------------
:nud_minus
	set push, 0
	set push, 1
	jsr preamble

	jsr lexer_next

	set push, 0x0150
	jsr expression
    set [z-1], x

	set push, x
	jsr eval
    set [z-1], x

	set y, 0
	ife [x + HANDLE_TYPE], TYPE_INT
		set y, int_negate
	ife [x + HANDLE_TYPE], TYPE_FLOAT
		set y, float_negate

	ife y, 0
		jsr recover

	set push, x
	jsr y

	set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_tilde()
;----------------------------------------------------------------
:nud_tilde
	set push, 0
	set push, 1
	jsr preamble

	jsr lexer_next

	set push, 0x0160
	jsr expression
    set [z-1], x

	set push, x
	jsr eval
    set [z-1], x

	ife [x + HANDLE_TYPE], TYPE_INT
		set pc, nud_tilde_int
		
	jsr recover

:nud_tilde_int
	set push, x
	jsr int_complement

	set pc, postamble

;----------------------------------------------------------------
; struct handle *nud_not()
;----------------------------------------------------------------
:nud_not
	set push, 0
	set push, 1
	jsr preamble

	jsr lexer_next

	set push, 0x0055
	jsr expression
    set [z-1], x

	set push, x
	jsr eval
    set [z-1], x

	set push, x
	jsr boolean
	set a, x

	set x, BOOL_HANDLE_FALSE
	ife a, BOOL_HANDLE_FALSE
		set x, BOOL_HANDLE_TRUE

	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_and(struct handle *left)
;----------------------------------------------------------------
:led_and
	set push, 1
	set push, 2
	jsr preamble

	jsr boolean_operator

	set x, BOOL_HANDLE_TRUE
    ife [z-1], BOOL_HANDLE_FALSE   
		set x, BOOL_HANDLE_FALSE
    ife [z-2], BOOL_HANDLE_FALSE   
		set x, BOOL_HANDLE_FALSE
			
	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_or(struct handle *left)
;----------------------------------------------------------------
:led_or
	set push, 1
	set push, 2
	jsr preamble

	jsr boolean_operator

	set x, BOOL_HANDLE_FALSE
    ife [z-1], BOOL_HANDLE_TRUE    
		set x, BOOL_HANDLE_TRUE
    ife [z-2], BOOL_HANDLE_TRUE    
		set x, BOOL_HANDLE_TRUE
			
	set pc, postamble

:boolean_operator
	jsr lexer_next

	; evaluate left side
	set push, [z+10]
	jsr eval
    set [z-1], x

	set push, x
	jsr boolean
    set [z-1], x

	; right side
	set c, [lexer_token]
	set push, [c + PROTOTYPE_LBP]		; push for expression call
	jsr expression
    set [z-2], x

	; evaluate right side
	set push, [z-2]
	jsr eval
    set [z-2], x
	
	set push, x
	jsr boolean
    set [z-2], x

	set pc, pop

;----------------------------------------------------------------
; struct handle *led_assign(struct handle *left)
;----------------------------------------------------------------
:led_is
	set push, 1
	set push, 2
	jsr preamble

	set a, TRUE

	jsr lexer_next
	ifn [lexer_token], token_not
		set a, FALSE
	ife [lexer_token], token_not
		jsr lexer_next
	
	; evaluate left side
	set push, [z+10]
	jsr eval
    set [z-1], x

	; parse right side
	set push, 0x0070
	jsr expression
    set [z-2], x
	
	; evaluate right side
    set push, [z-2]
	jsr eval
    set [z-2], x

	ife a, TRUE
		set pc, led_is_not

	set x, BOOL_HANDLE_FALSE
    ife x, [z-1]
		set x, BOOL_HANDLE_TRUE

	set pc, postamble

:led_is_not
	set x, BOOL_HANDLE_TRUE
    ife x, [z-1]
		set x, BOOL_HANDLE_FALSE

	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_not(struct handle *left)
;----------------------------------------------------------------
:led_not
	set push, 1
	set push, 2
	jsr preamble

	jsr lexer_next	; advance not

	set a, TRUE
	set pc, led_in_1

;----------------------------------------------------------------
; struct handle *led_in(struct handle *left)
;----------------------------------------------------------------
:led_in
	set push, 1
	set push, 2
	jsr preamble

	set a, FALSE

:led_in_1
	set push, token_in
	jsr lexer_advance	; verify led

; evaluate left side
	set push, [z+10]
	jsr eval
    set [z-1], x

	; parse right side
	set push, 0x0060
	jsr expression
    set [z-2], x
	
	; evaluate right side
    set push, [z-2]
	jsr eval
    set [z-2], x

	ife [x + HANDLE_TYPE], TYPE_STRING
		set pc, led_in_string

	ife [x + HANDLE_TYPE], TYPE_DICT
		set pc, led_in_dict

	ifb [x + HANDLE_TYPE], TYPE_TUPLE + TYPE_LIST
		set pc, led_in_list

	jsr recover

:led_in_string
	set push, x
    set push, [z-1]
	jsr str_search
	ife x, -1
		set pc, led_in_not_found
	set pc, led_in_found

:led_in_dict
	set push, x
    set push, [z-1]
	jsr dict_get
	ife x, 0
		set pc, led_in_not_found
	set pc, led_in_found

:led_in_list
	set push, x
    set push, [z-1]
	jsr array_find
	ife x, -1
		set pc, led_in_not_found
	set pc, led_in_found

:led_in_found
	set x, BOOL_HANDLE_TRUE
	ife a, TRUE
		set x, BOOL_HANDLE_FALSE
		
	set pc, postamble

:led_in_not_found
	set x, BOOL_HANDLE_FALSE
	ife a, TRUE
		set x, BOOL_HANDLE_TRUE
		
	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_less_or_equal(struct handle *left)
;----------------------------------------------------------------
:led_less_or_equal
	set push, 1
	set push, 2
	jsr preamble

	jsr compare_operator

	set x, BOOL_HANDLE_TRUE
	ife a, 1
		set x, BOOL_HANDLE_FALSE

	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_less(struct handle *left)
;----------------------------------------------------------------
:led_less
	set push, 1
	set push, 2
	jsr preamble

	jsr compare_operator

	set x, BOOL_HANDLE_FALSE
	ife a, -1
		set x, BOOL_HANDLE_TRUE

	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_greater_or_equal(struct handle *left)
;----------------------------------------------------------------
:led_greater_or_equal
	set push, 1
	set push, 2
	jsr preamble

	jsr compare_operator

	set x, BOOL_HANDLE_TRUE
	ife a, -1
		set x, BOOL_HANDLE_FALSE

	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_greater(struct handle *left)
;----------------------------------------------------------------
:led_greater
	set push, 1
	set push, 2
	jsr preamble

	jsr compare_operator

	set x, BOOL_HANDLE_FALSE
	ife a, 1
		set x, BOOL_HANDLE_TRUE

	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_not_equal(struct handle *left)
;----------------------------------------------------------------
:led_not_equal
	set push, 1
	set push, 2
	jsr preamble

	jsr compare_operator

	set x, BOOL_HANDLE_FALSE
	ifn a, 0
		set x, BOOL_HANDLE_TRUE

	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_equal(struct handle *left)
;----------------------------------------------------------------
:led_equal
	set push, 1
	set push, 2
	jsr preamble

	jsr compare_operator

	set x, BOOL_HANDLE_FALSE
	ife a, 0
		set x, BOOL_HANDLE_TRUE

	set pc, postamble

:compare_operator
	jsr lexer_next

	; right side
	set push, 0x0080
	jsr expression
    set [z-2], x

	; evaluate left side
	set push, [z+10]
	jsr eval
    set [z-1], x

	; evaluate right side
    set push, [z-2]
	jsr eval
    set [z-2], x
	
    set push, [z-1]
    set push, [z-2]
	jsr val_cmp
	set a, x

	set pc, pop

;----------------------------------------------------------------
; struct handle *led_plus(struct handle *left)
;----------------------------------------------------------------
:led_plus
	; todo str+str, tuple+tuple, list+list, int+int, float+int, int+float, float+float
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_plus_operation	
	
	set pc, postamble

:led_plus_operation
	jsr cast_common_number_type
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]
	
	ife c, TYPE_INT
		set y, int_add
	ife c, TYPE_FLOAT
		set y, float_add
	ife c, TYPE_STRING
		set y, array_merge
	ife c, TYPE_LIST
		set y, array_merge
	ife c, TYPE_TUPLE
		set y, array_merge

:led_operation_tailer
	set push, a
	set push, b
	jsr y

	set pc, pop

;----------------------------------------------------------------
; struct handle *led_minus(struct handle *left)
;----------------------------------------------------------------
:led_minus
	; todo int-int, float-int, int-float, float-float
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_minus_operation	
	
	set pc, postamble

:led_minus_operation
	jsr cast_common_number_type
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_sub
	ife c, TYPE_FLOAT
		set y, float_sub

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_star(struct handle *left)
;----------------------------------------------------------------
:led_star
	; todo int*int, int*float, float*int, float*float, int*str, str*int, int*tuple, tuple*int, int*list, list*int
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_star_operation	
	
	set pc, postamble

:led_star_operation
	jsr cast_common_number_type
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_mul
	ife c, TYPE_FLOAT
		set y, float_mul
	ife c, TYPE_STRING + TYPE_INT
		set y, array_repeat
	ife c, TYPE_TUPLE + TYPE_INT
		set y, array_repeat
	ife c, TYPE_LIST + TYPE_INT
		set y, array_repeat

	ifn [a + HANDLE_TYPE], TYPE_INT
		set pc, led_operation_tailer

	; swap a and b
	set ex, a
	set a, b
	set b, ex

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_power(struct handle *left)
;----------------------------------------------------------------
:led_power
	; todo int*int, int*float, float*int, float*float
	set push, 1
	set push, 2
	jsr preamble

	jsr infixr
	jsr led_power_operation	
	
	set pc, postamble

:led_power_operation
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_pow
		
	ife [a + HANDLE_TYPE], TYPE_FLOAT
		ife [b + HANDLE_TYPE], TYPE_INT
			set y, float_pow

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_bitwise_or(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_or
	; int*int
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_bitwise_or_operation	
	
	set pc, postamble

:led_bitwise_or_operation
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_bitwise_or

	set pc, led_operation_tailer


;----------------------------------------------------------------
; struct handle *led_bitwise_xor(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_xor
	; int*int
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_bitwise_xor_operation	
	
	set pc, postamble

:led_bitwise_xor_operation
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_bitwise_xor

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_bitwise_and(struct handle *left)
;----------------------------------------------------------------
:led_bitwise_and
	; int*int
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_bitwise_and_operation	
	
	set pc, postamble

:led_bitwise_and_operation
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_bitwise_and

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_lshift(struct handle *left)
;----------------------------------------------------------------
:led_lshift
	; int << int
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_lshift_operation	
	
	set pc, postamble

:led_lshift_operation
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_lshift

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_rshift(struct handle *left)
;----------------------------------------------------------------
:led_rshift
	; int >> int
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_rshift_operation	
	
	set pc, postamble

:led_rshift_operation
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_rshift

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_slash(struct handle *left)
;----------------------------------------------------------------
:led_slash
	; todo int/int, int/float, float/int, float/float
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_slash_operation	
	
	set pc, postamble

:led_slash_operation
	jsr cast_common_number_type
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_div
	ife c, TYPE_FLOAT
		set y, float_div

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_percent(struct handle *left)
;----------------------------------------------------------------
:led_percent
	; todo int/int, int/float, float/int, float/float
	set push, 1
	set push, 2
	jsr preamble

	jsr infix
	jsr led_percent_operation	
	
	set pc, postamble

:led_percent_operation
	set c, [a + HANDLE_TYPE]
	bor c, [b + HANDLE_TYPE]

	ife c, TYPE_INT
		set y, int_mod

	set pc, led_operation_tailer

;----------------------------------------------------------------
; struct handle *led_assign(struct handle *left)
;----------------------------------------------------------------
:led_assign
	set push, 1
	set push, 1
	jsr preamble

	jsr lexer_next

	; right side
	set push, 0x0009 					; right binding power
	jsr expression
    set [z-1], x
	
	set push, x
	jsr eval
    set [z-1], x

	set push, [z+10]
	set push, x
	jsr assign
	
	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_cond_assign(struct handle *left)
;----------------------------------------------------------------
:led_cond_assign
	set push, 1
	set push, 1
	jsr preamble

	jsr lexer_next					; skip '?='

	; right side
	set push, 0x0009 					; right binding power
	jsr expression
    set [z-1], x
	
	set push, [current_scope]
	set push, [z+10]
	jsr scope_get
	
	ifn x, 0
		set pc, postamble

    set push, [z-1]
	jsr eval
    set [z-1], x

	set push, [z+10]
	set push, x
	jsr assign
	
	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_prototype(struct handle *left)
;----------------------------------------------------------------
:led_prototype
	set push, 1
	set push, 2
	jsr preamble

	jsr lexer_next					; skip ':='

	; right side
	set push, 0x0009 					; right binding power
	jsr expression
    set [z-1], x
	
	set push, x
	jsr eval
    set [z-1], x

	; prototyping is available only for dicts
	ifn [x + HANDLE_TYPE], TYPE_DICT
		jsr recover

	set push, 5
	set push, TYPE_DICT
	jsr alloc
    set [z-2], x
	
	set push, x
	set push, STR_UNDERSCORE
    set push, [z-1]
	jsr dict__set

	set push, [z+10]
    set push, [z-2]
	jsr assign

    set x, [z-2]
	set pc, postamble

:led_augass
	; we cheat here, as stack is wrongly organized
	; z+10
	; rts
	; z+11
	; we must copy rts and z11 to get proper stack bottom
	set push, [sp+2]
	set push, [sp+2]

	; here we claim 4 parameters, to make postamble clean them all
	set push, 4
	set push, 2
	jsr preamble

	jsr infixr

	jsr [z+11]
    set [z-1], x

	set push, [z+10]
	set push, x
	jsr assign
	
	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_augass_lshift(struct handle *left)
;----------------------------------------------------------------
:led_augass_lshift
	set push, led_lshift_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_rshift(struct handle *left)
;----------------------------------------------------------------
:led_augass_rshift
	set push, led_rshift_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_or(struct handle *left)
;----------------------------------------------------------------
:led_augass_or
	set push, led_bitwise_or_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_xor(struct handle *left)
;----------------------------------------------------------------
:led_augass_xor
	set push, led_bitwise_xor_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_and(struct handle *left)
;----------------------------------------------------------------
:led_augass_and
	set push, led_bitwise_and_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_plus(struct handle *left)
;----------------------------------------------------------------
:led_augass_plus
	set push, led_plus_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_minus(struct handle *left)
;----------------------------------------------------------------
:led_augass_minus
	set push, led_minus_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_star(struct handle *left)
;----------------------------------------------------------------
:led_augass_star
	set push, led_star_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_slash(struct handle *left)
;----------------------------------------------------------------
:led_augass_slash
	set push, led_slash_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_augass_percent(struct handle *left)
;----------------------------------------------------------------
:led_augass_percent
	set push, led_percent_operation
	set pc, led_augass

;----------------------------------------------------------------
; struct handle *led_lparen(struct handle *left)
; function call
;----------------------------------------------------------------
:led_lparen
	set push, 1
	set push, 4
	jsr preamble

	set pc, built_in

:led_lparen_user_defined
	set c, '0'	; num unnamed_args

	; prepare scope
	set push, 10		; create scope for function call
	set push, TYPE_DICT
	jsr alloc
    set [z-1], x

	set push, x			; add global scope (ex)
	set push, STR_EX
	set push, [global_scope]
	jsr dict__set
	
	set a, [z+10]		; if call is by reference, add path dict to scope (me)
	ifn [a + HANDLE_TYPE], TYPE_REFERENCE
		set pc, led_lparen_args
		
	set a, [a]			; a = struct reference *
		
    set push, [z-1]
	set push, STR_ME
	set push, [a + REFERENCE_DICT]
	jsr dict__set

:led_lparen_args
	jsr lexer_next	; skip '(' or ','

	ife [lexer_token], token_rparen
		set pc, led_lparen_prepare_call

	jsr parse_testlist_item
    set push, [z-1]
    set push, [z-2]
    set push, [z-3]
	jsr dict__set
	
	ife [lexer_token], token_comma
		set pc, led_lparen_args

:led_lparen_prepare_call
	set push, token_rparen
	jsr lexer_advance	; skip ')'

	set push, [z+10]
	jsr eval
    set [z-2], x
	
	ifn [x + HANDLE_TYPE], TYPE_STRING
		jsr recover	

	set push, [current_scope]
    set [current_scope], [z-1]

	jsr lexer_store

    set x, [z-2]
	jsr lexer_init

:led_lparen_call
	jsr parser_stmt

	ife [x+HANDLE_TYPE], TYPE_CONTROL
		set pc, led_lparen_control

	ifn [lexer_token], token_eof
		set pc, led_lparen_call

	set a, NONE

:led_lparen_finish
	jsr lexer_restore
	set [current_scope], [sp+6]
	set x, a
	set pc, postamble

:led_lparen_control
	set a, [x]
	ifn [a + CONTROL_SIGNAL], token_return
		jsr recover			; break and continue

	set push, [a + CONTROL_VALUE]
	jsr eval
	set a, x
	
	set pc, led_lparen_finish

;----------------------------------------------------------------
:parse_testlist_item
;----------------------------------------------------------------
	; read value or name	
	set push, 0x0030
	jsr expression
    set [z-2], x

	ife [lexer_token], token_assign
		; parameter value
		set pc, parse_testlist_item_assign

	; f(1) -> $0=1
    set [z-3], x

	set push, 2
	set push, TYPE_NAME
	jsr array_create
    set [z-2], x

	sti i, [x]
	sti [i], '$'
	set [i], c
	add c, 1

	set pc, parse_testlist_item_set

:parse_testlist_item_assign
	; f(a=1)
	ifn [x+1], TYPE_NAME
		jsr recover	

	jsr lexer_next	; skip '='

	; read value
	set push, 0x0030
	jsr expression
    set [z-3], x

:parse_testlist_item_set
    set push, [z-3]
	jsr eval
    set [z-3], x

	set pc, pop

;----------------------------------------------------------------
; struct handle *led_lbrack(struct handle *left)
;----------------------------------------------------------------
:led_lbrack
	set push, 1
	set push, 3
	jsr preamble

	jsr lexer_next			; skip '['

	; eval left side
	set push, [z+10]
	jsr eval
    set [z-1], x

	ife [x + HANDLE_TYPE], TYPE_DICT	; branch dict
		set pc, led_lbrack_dict

	ifc [x + HANDLE_TYPE], TYPE_STRING + TYPE_TUPLE + TYPE_LIST
		jsr recover

	; handle str, tuple, list
	ifn [lexer_token], token_colon
		set pc, led_lbrack_parse_first

	; no slice start, assume 0
    set [z-2], INT_HANDLE_0
	set pc, led_lbrack_after_colon

:led_lbrack_parse_first
	; parse slice start or index
	set push, 0
	jsr expression
    set [z-2], x
	
	set push, x
	jsr eval
    set [z-2], x

	ifn [lexer_token], token_colon
		set pc, led_lbrack_finish	; no colon -> index

:led_lbrack_after_colon
	jsr lexer_next				; skip ':'
	; [z-2] now contains slice start
    set [z-3], [z-2]

	set push, 2
	set push, TYPE_TUPLE
	jsr array_create
    set [z-2], x

	set x, [x]
    set [x+1], [z-3]           ; slice start

	ife [lexer_token], token_rbrack
		set pc, led_lbrack_empty_after_colon

	set push, 0
	jsr expression
	set [z-3], x
	
	set push, x
	jsr eval
	set [z-3], x

	set a, [z-2]
	set a, [a]
	set [a+2], [z-3]		; slice end

	set pc, led_lbrack_finish

:led_lbrack_empty_after_colon
	; set array len to slice end
	set a, [z-1]
	set a, [a]

	set push, [a]
	jsr int16_to_int
	set [z-3], x
	
	set a, [z-2]
	set a, [a]
	set [a+2], [z-3]		; slice end
	
	set pc, led_lbrack_finish

:led_lbrack_dict
	set push, 0
	jsr expression
	set [z-2], x
		
	set push, x
	jsr eval
	set [z-2], x

	ifc [x + HANDLE_TYPE], TYPE_STRING + TYPE_TUPLE + TYPE_INT + TYPE_BOOLEAN + TYPE_FLOAT
		jsr recover

:led_lbrack_finish
	set push, token_rbrack
	jsr lexer_advance

	; construct return value
	set push, 2
	set push, TYPE_SUBSCRIPTION
	jsr array_create
	set [z-3], x			; result

	set a, [x]
	set [a + SUBSCRIPTION_LIST], [z-1]
	set [a + SUBSCRIPTION_INDEX], [z-2]

	set pc, postamble

;----------------------------------------------------------------
; struct handle *led_reference(struct handle *left)
; attribute reference
;----------------------------------------------------------------
:led_reference
	set push, 1
	set push, 3
	jsr preamble

	set push, 2
	set push, TYPE_REFERENCE
	jsr array_create
	set [z-1], x
	
	set push, [z+10]
	jsr eval
	
	ifn [x + 1], TYPE_DICT
		jsr recover

	set a, [z-1]
	set a, [a]
	set [a + REFERENCE_DICT], x
	
	jsr lexer_next

	ifn [lexer_token], token_name
		jsr recover

	jsr lexer_get_token_as_string

	set a, [z-1]
	set a, [a]
	set [a + REFERENCE_NAME], x

	jsr lexer_next
	
	set x, [z-1]
	set pc, postamble

;----------------------------------------------------------------
:infixr
	set a, [lexer_token]
	set a, [a + PROTOTYPE_LBP]		; push for expression call
	sub a, 1
	set push, a
	set pc, infix_1

;----------------------------------------------------------------
:infix
; fastcall
; return 
;   a: struct handle *left
;   b: struct handle *right
;   y: 0
;----------------------------------------------------------------
	set a, [lexer_token]
	set push, [a + PROTOTYPE_LBP]		; push for expression call

:infix_1
	; left
	set push, [z+10]
	jsr eval
	set [z-1], x
	set a, x

	jsr lexer_next

	; right side
	jsr expression
	set [z-2], x

	set push, x
	jsr eval
	set [z-2], x
	set b, x
	
	set y, recover

	set pc, pop
	
;----------------------------------------------------------------
; struct handle *led_comma(struct handle *left)
; tuple
;----------------------------------------------------------------
:led_comma
	set push, 1
	set push, 2
	jsr preamble

	set a, [z+10]
	set [z-1], a
	ife [a + HANDLE_TYPE], TYPE_TUPLE_COMMA
		set pc, led_comma_add
		
	set push, 5
	set push, TYPE_TUPLE_COMMA
	jsr alloc
	set [z-1], x

	set x, [x]
	set [x], 1
	set [x+1], a
	
:led_comma_add
	jsr lexer_next

	set a, [lexer_token]
	ifn [a + PROTOTYPE_STD], std_expression
		set pc, led_comma_end

	set push, 0x0020
	ife [z+9], expression_callback
		jsr expression
	ife [z+9], testlist_callback
		jsr testlist	
	set [z-2], x

	set push, [z-1]
	set push, -1
	set push, [z-2]
	jsr array_insert

:led_comma_end
	set x, [z-1]	; expr
	set pc, postamble


;----------------------------------------------------------------
:built_in
;----------------------------------------------------------------
	set a, [z+10]
	set a, [a]
	
	set b, [a]
	add a, 1
	
	set x, built_in_functions
	jsr built_in_matcher
	set pc, c

;----------------------------------------------------------------
:built_in_id
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover
		
	set push, [z-1]
	jsr uint16_to_int

	set pc, postamble

;----------------------------------------------------------------
:built_in_input
;----------------------------------------------------------------
	jsr built_in_params

	ifg i, 1
		jsr recover

	set push, [z-1]
	jsr raw_input
	set [z-1], x

	set a, [x]
	sub [a], 1

	set c, 10
	jsr screen_add_char

	set x, [z-1]
	set pc, postamble
	
;----------------------------------------------------------------
:built_in_range
;----------------------------------------------------------------
	jsr built_in_params

	ife i, 0
		jsr recover

	ifg i, 1
		set pc, built_in_range_2

	set [z-2], [z-1]
	set [z-1], INT_HANDLE_0

:built_in_range_2	
	ifg i, 2
		set pc, built_in_range_3

	set [z-3], INT_HANDLE_1

:built_in_range_3
	ifg i, 3
		jsr recover

	set push, [z-3]
	jsr int_sgn
	set y, x
	xor y, 0xffff
	add y, 1

	set push, 20
	set push, TYPE_LIST
	jsr alloc
	set [z-4], x

:built_in_range_loop
	set push, [z-1]
	set push, [z-2]
	jsr val_cmp
	
	ifn x, y
		set pc, built_in_range_break

	set push, [z-4]
	set push, -1
	set push, [z-1]
	jsr array_insert	

	set push, [z-1]
	set push, [z-3]
	jsr int_add
	set [z-1], x
	
	set pc, built_in_range_loop

:built_in_range_break
	set x, [z-4]
	set pc, postamble

;----------------------------------------------------------------
:built_in_mem
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 0
		jsr recover

	jsr mark
	jsr compact

	set a, [heap_handle_start]
	sub a, [heap_free_start]
	
	set push, a
	jsr uint16_to_int

	set pc, postamble	

;----------------------------------------------------------------
:built_in_locals
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 0
		jsr recover

	set x, [current_scope]
	set pc, postamble	

;----------------------------------------------------------------
:built_in_globals
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 0
		jsr recover

	set x, [global_scope]
	set pc, postamble	

;----------------------------------------------------------------
:built_in_cmp
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 2
		jsr recover

	set push, [z-1]
	set push, [z-2]
	jsr val_cmp
	set a, x
	
	set x, INT_HANDLE_0
	ife a, -1
		set x, INT_HANDLE_N1
	ife a, 1
		set x, INT_HANDLE_1
	
	set pc, postamble

;----------------------------------------------------------------
:built_in_chr
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set a, [z-1]
	ifn [a + HANDLE_TYPE], TYPE_INT
		jsr recover

	set a, [a]
	ifn [a], 1
		jsr recover

	set a, [a+1]

	set push, 1
	set push, TYPE_STRING
	jsr array_create
	
	sti i, [x]
	set [i], a

	set pc, postamble	

;----------------------------------------------------------------
:built_in_ord
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set a, [z-1]
	ifn [a + HANDLE_TYPE], TYPE_STRING
		jsr recover

	set a, [a]
	ifn [a], 1
		jsr recover

	set push, [a+1]
	jsr int16_to_int

	set pc, postamble	

;----------------------------------------------------------------
:built_in_edit
;----------------------------------------------------------------
	jsr built_in_params
	ifg i, 1
		jsr recover

	set a, [z-1]
	ife i, 0
		set a, STR_EMPTY

	ifn [a + HANDLE_TYPE], TYPE_STRING
		jsr recover

	set push, a
	jsr edit_main

	set pc, postamble	

;----------------------------------------------------------------
:built_in_rnd
;----------------------------------------------------------------
	jsr built_in_params
	ifg i, 0
		set pc, built_in_rnd_1
		
	set a, [FLOAT_0]
	set b, [FLOAT_1]
	
	set pc, built_in_rnd_finish

:built_in_rnd_1
	ifg i, 1
		set pc, built_in_rnd_2

	set b, [z-1]
	set c, [b + HANDLE_TYPE]

	ifc c, TYPE_INT + TYPE_FLOAT
		jsr recover

	set a, INT_HANDLE_0
	ife c, TYPE_FLOAT
		set a, [FLOAT_0]

	set pc, built_in_rnd_finish

:built_in_rnd_2
	set a, [z-1]
	set b, [z-2]

	ifc [a + HANDLE_TYPE], TYPE_FLOAT + TYPE_INT
		jsr recover
	ifc [b + HANDLE_TYPE], TYPE_FLOAT + TYPE_INT
		jsr recover

:built_in_rnd_finish
	jsr cast_common_number_type

	set y, int_random
	ife [a + HANDLE_TYPE], TYPE_FLOAT
		set y, float_random

	set push, a
	set push, b
	jsr y	

	set pc, postamble

;----------------------------------------------------------------
:built_in_abs
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set a, [z-1]

	set y, 0
	
	ifb [a + HANDLE_TYPE], TYPE_INT + TYPE_BOOLEAN
		set y, int_abs
	ifb [a + HANDLE_TYPE], TYPE_FLOAT
		set y, float_abs

	ife y, 0
		jsr recover

	set push, a
	jsr y

	set pc, postamble	

;----------------------------------------------------------------
:built_in_len
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set a, [z-1]
	ifc [a + HANDLE_TYPE], TYPE_STRING + TYPE_TUPLE + TYPE_DICT + TYPE_LIST
		jsr recover

	set a, [a]

	set push, [a]
	jsr int16_to_int

	set pc, postamble	

;----------------------------------------------------------------
:built_in_dir
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 0
		jsr recover

	jsr floppy__dir__read

	set pc, postamble	

;----------------------------------------------------------------
:built_in_format
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 0
		jsr recover

	jsr floppy__format

	set pc, postamble	

;----------------------------------------------------------------
:built_in_load
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set a, [z-1]
	ifc [a + HANDLE_TYPE], TYPE_STRING
		jsr recover

	set push, a
	jsr floppy__file__read

	set pc, postamble	

;----------------------------------------------------------------
:built_in_save
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 2
		jsr recover

	set a, [z-1]
	ifc [a + HANDLE_TYPE], TYPE_STRING
		jsr recover

	set push, a
	set push, [z-2]
	jsr floppy__file__write

	set pc, postamble	

;----------------------------------------------------------------
:built_in_rm
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set a, [z-1]
	ifc [a + HANDLE_TYPE], TYPE_STRING
		jsr recover

	set push, a
	jsr floppy__file__delete

	set pc, postamble	

;----------------------------------------------------------------
:built_in_int
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set a, [z-1]

	ife [a + HANDLE_TYPE], TYPE_INT
		set pc, built_in_int_int
	ife [a + HANDLE_TYPE], TYPE_BOOLEAN
		set pc, built_in_int_bool
	ife [a + HANDLE_TYPE], TYPE_STRING
		set pc, built_in_int_string
	ife [a + HANDLE_TYPE], TYPE_FLOAT
		set pc, built_in_int_float

	jsr recover

:built_in_int_int
	set x, a
	set pc, postamble

:built_in_int_bool
	ife a, BOOL_HANDLE_FALSE
		set x, INT_HANDLE_0
	ife a, BOOL_HANDLE_TRUE
		set x, INT_HANDLE_1
	set pc, postamble

:built_in_int_string
	set push, a
	jsr int_parse
	set pc, postamble

:built_in_int_float
	set push, a
	jsr float_to_int
	set pc, postamble

;----------------------------------------------------------------
:built_in_float
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set a, [z-1]

	ife [a + HANDLE_TYPE], TYPE_INT
		set pc, built_in_float_int
	ife [a + HANDLE_TYPE], TYPE_BOOLEAN
		set pc, built_in_float_bool
	ife [a + HANDLE_TYPE], TYPE_STRING
		set pc, built_in_float_string
	ife [a + HANDLE_TYPE], TYPE_FLOAT
		set pc, built_in_float_float

	jsr recover

:built_in_float_int
	set push, a
	jsr float_from_int
	set pc, postamble

:built_in_float_bool
	ife a, BOOL_HANDLE_FALSE
		set x, [FLOAT_0]
	ife a, BOOL_HANDLE_TRUE
		set x, [FLOAT_1]
	set pc, postamble

:built_in_float_string
	set push, a
	jsr float_from_str
	set pc, postamble

:built_in_float_float
	set x, a
	set pc, postamble
	
;----------------------------------------------------------------
:built_in_repr
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set push, [z-1]
	jsr repr
	set [z-1], x
	
	set pc, postamble

;----------------------------------------------------------------
:built_in_str
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set x, [z-1]

	ife [x + HANDLE_TYPE], TYPE_STRING
		set pc, postamble

	set push, x
	jsr repr

	set pc, postamble

;----------------------------------------------------------------
:built_in_bool
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 1
		jsr recover

	set push, [z-1]
	jsr boolean

	set pc, postamble

;----------------------------------------------------------------
:built_in_getchar
;----------------------------------------------------------------
	jsr built_in_params
	ifn i, 0
		jsr recover

:built_in_getchar_loop
	set a, 1              ; store next key mode
	hwi [keyboard]

	ife c, 0
		set pc, built_in_getchar_loop

	set push, 1
	set push, TYPE_STRING
	jsr array_create
	
	sti i, [x]
	set [i], c

	set pc, postamble	

;----------------------------------------------------------------
:built_in_key
;----------------------------------------------------------------
	jsr built_in_params
	ife i, 1
		set pc, built_in_key_1
	
	ifn i, 0
		jsr recover

	set a, 1              ; store next key mode
	hwi [keyboard]
	
	set x, INT_HANDLE_0
	ife c, 0
		set pc, postamble 

	set push, c
	jsr int16_to_int

	set pc, postamble

:built_in_key_1
	set a, [z-1]
	ife [a + HANDLE_TYPE], TYPE_INT
		set pc, built_in_key_1_int
		
	ifn [a + HANDLE_TYPE], TYPE_STRING
		jsr recover
		
	set a, [a]
	ifn [a], 1
		jsr recover

	set b, [a + 1]
	set pc, built_in_key_1_key

:built_in_key_1_int
	set push, a
	jsr int_to_int16
	set b, x

:built_in_key_1_key
	set a, 2              ; store next key mode
	hwi [keyboard]
	
	set x, BOOL_HANDLE_TRUE
	ife c, 0
		set x, BOOL_HANDLE_FALSE

	set pc, postamble

;----------------------------------------------------------------
:built_in_sort
;----------------------------------------------------------------
	jsr built_in_params
	ifg i, 1
		jsr built_in_sort_2

	set push, [z-1]
	set push, BOOL_HANDLE_FALSE
	jsr sort
	
	set pc, postamble

:built_in_sort_2
	ifg i, 2
		jsr recover
	
	set push, [z-1]
	set push, [z-2]
	jsr sort

	set pc, postamble

;----------------------------------------------------------------
:built_in_params
; util function used by built-in impls to parse arguments
;----------------------------------------------------------------
	set i, 0	; param counter

:built_in_params_loop
	jsr lexer_next	; skip '(' or ','

	ife i, 3
		set pc, built_in_params_end
	ife [lexer_token], token_rparen
		set pc, built_in_params_end

	set push, 0x0030
	jsr expression

	sti a, z
	sub a, i
	set [a], x

	set push, x
	jsr eval
	set [a], x
	

	ife [lexer_token], token_comma
		set pc, built_in_params_loop

:built_in_params_end
	set push, token_rparen
	jsr lexer_advance	; skip ')'

	set pc, pop
