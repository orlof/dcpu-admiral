;----------------------------------------------------------------
; void float_create(uint category, uint exponent, uint mantissa_pattern)
;----------------------------------------------------------------
:float_create
	set push, 3
	set push, 1
	jsr preamble
	
	set push, SIZEOF_FLOAT
	set push, TYPE_FLOAT
	jsr alloc
	set [z-1], x
	
	set i, [x]
	sti [i], [z+12]
	sti [i], [z+11]

	set a, i
	add a, FLOAT_PRECISION - 1

:float_create_loop
	set [i], [z+10]
	ifl i, a
		sti pc, float_create_loop	

	set push, [builtin]
	set push, -1
	set push, x
	jsr array_insert

	set x, [z-1]
	set pc, postamble

;----------------------------------------------------------------
; void float_init(void)
;----------------------------------------------------------------
:float_init
	set push, 0
	set push, 1
	jsr preamble
	
	set push, FLOAT_CATEGORY_NAN
	set push, 0xffff
	set push, 0xffff
	jsr float_create
	set [FLOAT_NAN], x

	set push, FLOAT_CATEGORY_PINF
	set push, 0xffff
	set push, 0x0000
	jsr float_create
	set [FLOAT_PINF], x
	
	set push, FLOAT_CATEGORY_NINF
	set push, 0xffff
	set push, 0x0000
	jsr float_create
	set [FLOAT_NINF], x

	set push, FLOAT_CATEGORY_PZERO
	set push, 0x0000
	set push, 0x0000
	jsr float_create
	set [FLOAT_PZERO], x
	
	set push, FLOAT_CATEGORY_NZERO
	set push, 0x0000
	set push, 0x0000
	jsr float_create
	set [FLOAT_NZERO], x

	set i, 0
	set j, FLOAT_0
	
:float_init_loop
	set push, i
	jsr float_from_uint
	set [z-1], x
	set [j], x

	set push, [builtin]
	set push, -1
	set push, x
	jsr array_insert

	ifl i, 10
		sti pc, float_init_loop

	set pc, postamble

;----------------------------------------------------------------
; struct handle *float_cmp(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_cmp
	set push, 2
	set push, 0
	jsr preamble

	set i, [z+11]
	set i, [i]

	set j, [z+10]
	set j, [j]

	; sort arg1 - reorder -0 and -inf
	set a, [i + FLOAT_CATEGORY]
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NINF
		set a, FLOAT_CATEGORY_NZERO
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NZERO
		set a, FLOAT_CATEGORY_NINF

	; move nan to msb
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
		set a, 0x8000

	; sort arg1 - reorder -0 and -inf
	set b, [j + FLOAT_CATEGORY]
	ife [j + FLOAT_CATEGORY], FLOAT_CATEGORY_NINF
		set b, FLOAT_CATEGORY_NZERO
	ife [j + FLOAT_CATEGORY], FLOAT_CATEGORY_NZERO
		set b, FLOAT_CATEGORY_NINF

	; move nan to msb
	ife [j + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
		set b, 0x8000

	;---------------------------------------
	; compare categories
	;---------------------------------------
	set x, 1
	ifg a, b
		set pc, postamble

	set x, -1
	ifl a, b
		set pc, postamble

	; numbers are in the same non-number category
	set x, 0
	ifc a, FLOAT_CATEGORY_PNUM + FLOAT_CATEGORY_NNUM
		set pc, postamble

	;---------------------------------------
	; compare positive or negative numbers
	;---------------------------------------
	sti c, i
	add c, FLOAT_PRECISION + 1		; last word of mantissa
	
:float_cmp_loop
	ifg [i], [j]
		set pc, float_cmp_gt

	ifl [i], [j]
		set pc, float_cmp_lt

	ifl i, c
		sti pc, float_cmp_loop

	; numbers are equal
	set x, 0
	set pc, postamble

:float_cmp_gt
	set x, 1
	ifb a, FLOAT_MASK_NEGATIVE
		set x, -1
	set pc, postamble

:float_cmp_lt
	set x, -1
	ifb b, FLOAT_MASK_NEGATIVE
		set x, 1
	set pc, postamble

;----------------------------------------------------------------
; struct handle *float_clone(struct handle *f)
;----------------------------------------------------------------
:float_clone
	set push, 1
	set push, 1
	jsr preamble
	
	set push, SIZEOF_FLOAT
	set push, TYPE_FLOAT
	jsr alloc
	set [z-1], x

	set i, [z+10]
	set i, [i]
	add i, SIZEOF_FLOAT - 1
	
	set j, x
	set j, [j]
	add j, SIZEOF_FLOAT - 1
	
:float_clone_loop
	set [j], [i]
	ifg j, [x]
		std pc, float_clone_loop

	set pc, postamble
	
;----------------------------------------------------------------
; struct handle *float_add(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_add
	set push, 2
	set push, 3
	jsr preamble

	set i, [z+11]
	set i, [i]
	
	set j, [z+10]
	set j, [j]

	;---------------------------------------
	; check special cases
	;---------------------------------------
	set a, [i + FLOAT_CATEGORY]
	bor a, [j + FLOAT_CATEGORY]

	; if arg1 or arg2 is nan	
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
		set pc, float_postamble_nan
	ife [j + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
		set pc, float_postamble_nan
	
	; if args are +inf and -inf	
	ife a, FLOAT_CATEGORY_PINF + FLOAT_CATEGORY_NINF
		set pc, float_postamble_nan

	; if arg1 or arg2 is +inf
	ifb a, FLOAT_CATEGORY_PINF
		set pc, float_postamble_pinf

	; if arg1 or arg2 is -inf
	ifb a, FLOAT_CATEGORY_NINF
		set pc, float_postamble_ninf

	;---------------------------------------
	; [z-1] = abs([z+11])
	;---------------------------------------
	set push, [z+11]
	jsr float_abs
	set [z-1], x

	;---------------------------------------
	; [z-2] = abs([z+10])
	;---------------------------------------
	set push, [z+10]
	jsr float_abs
	set [z-2], x

	;---------------------------------------
	; [z-2] = ([z-1] < [z-2]) ? [z+11]: [z+10]
	; [z-1] = clone(([z-1] >= [z-2]) ? [z+11]: [z+10])
	;---------------------------------------
	set push, [z-1]
	set push, [z-2]
	jsr float_cmp

	ife x, -1
		set [z-2], [z+11]
	ifn x, -1
		set [z-2], [z+10]

	ife x, -1
		set push, [z+10]
	ifn x, -1
		set push, [z+11]

	jsr float_clone
	set [z-1], x

	;---------------------------------------
	; align exponents
	;---------------------------------------
	set i, [z-1]		; struct handle *
	set i, [i]			; struct float *max
	
	set j, [z-2]		; struct handle *
	set j, [j]			; struct float *min

	; quick exit if [z-2] is zero
	ifb [j + FLOAT_CATEGORY], FLOAT_CATEGORY_PZERO + FLOAT_CATEGORY_NZERO
		set pc, float_postamble

	; which method to use?
	set push, float_add_by_sub
	ife [j + FLOAT_CATEGORY], [i + FLOAT_CATEGORY]
		set [sp], float_add_by_add

	; calculate exponent diff
	set a, [i + FLOAT_EXPONENT]
	sub a, [j + FLOAT_EXPONENT]
	
	;---------------------------------------
	; set x, y point to mantissa msw
	;---------------------------------------
	set x, i
	add x, FLOAT_MANTISSA
	add i, FLOAT_MANTISSA + FLOAT_PRECISION - 1

	set y, j
	add y, FLOAT_MANTISSA
	add j, FLOAT_MANTISSA + FLOAT_PRECISION - 1

	; calculate amount of word shifts
	set b, a
	div b, 16
	
	; quick exit if arg2 is too small
	ifg b, FLOAT_PRECISION - 1
		set pc, float_postamble

	; skip b lsw
	sub j, b

	; calculate amount of bit shifts
	mod a, 16

	; init carry with zero
	set c, 0

	; init lsb part of 1st word
	set b, [j]
	shr b, a

	; call add or sub (this is not rts)
	set pc, pop

:float_add_by_sub
	;---------------------------------------
	; loop that bit shifts and subtracts
	;---------------------------------------
	sub [i], c
	ifn ex, 0
		set c, 1
		
	sub [i], b
	ifn ex, 0
		set c, 1
		
	set b, 0
	ifg j, y
		set b, [j-1]
		
	shr b, a
	sub [i], ex
	ifn ex, 0
		set c, 1
	
	ifg i, x
		std pc, float_add_by_sub

	set push, [z-1]
	jsr float_normalize
	
	set pc, postamble

:float_add_by_add
	set ex, c
	adx [i], b
	set c, ex
	
	set b, 0
	ifg j, y
		set b, [j-1]
		
	shr b, a
	add [i], ex
	bor c, ex
	
	ifg i, x
		std pc, float_add_by_add

	ife c, 0
		set pc, float_postamble

	add i, FLOAT_PRECISION - 1
	set y, i

:float_add_by_add_shift_loop
	shr [i], 1
	ifl i, y
		bor [i+1], ex
	ifg i, x
		std pc, float_add_by_add_shift_loop
		
	bor [i], 0x8000
	add [i-1], 1
	ifn ex, 0
		set pc, float_postamble_pinf
		
	set pc, float_postamble
	
;----------------------------------------------------------------
; struct handle *float_sub(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_sub
	set push, 2
	set push, 1
	jsr preamble

	set push, [z+10]
	jsr float_negate
	set [z-1], x

	set push, [z+11]
	set push, [z-1]
	jsr float_add

	set pc, postamble

;----------------------------------------------------------------
; struct handle *float_mul(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_mul
	set push, 2
	set push, 1
	jsr preamble

	set i, [z+11]		; struct handle *f1
	set j, [z+10]		; struct handle *f2

	;---------------------------------------
	; check special cases
	;---------------------------------------
	set a, [i]			; struct float *f1
	set b, [j]			; struct float *f2
	
	set a, [a + FLOAT_CATEGORY]
	set b, [b + FLOAT_CATEGORY]

	; arg1 or arg2 is nan	
	ife a, FLOAT_CATEGORY_NAN
		set pc, float_postamble_nan
	ife b, FLOAT_CATEGORY_NAN
		set pc, float_postamble_nan

	set c, a
	bor c, b

	; one arg is zero and other is inf
	ifb c, FLOAT_CATEGORY_NINF + FLOAT_CATEGORY_PINF
		ifb c, FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
			set pc, float_postamble_nan

	set push, SIZEOF_FLOAT
	set push, TYPE_FLOAT
	jsr alloc
	set [z-1], x
	set y, [x]

	set i, [i]
	set j, [j]

	; deduce result sign
	set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_PNUM
	ifb c, FLOAT_MASK_POSITIVE
		ifb c, FLOAT_MASK_NEGATIVE
			set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NNUM

	; arg is inf, postamble with deduced sign
	ifb c, FLOAT_CATEGORY_NINF + FLOAT_CATEGORY_PINF
		set pc, float_postamble_inf
			
	; arg is zero, postamble with deduced sign
	ifb c, FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
		set pc, float_postamble_zero

	;---------------------------------------
	; calculate exponent
	;---------------------------------------
	; is all this really needed to detect overflow?
    set a, [i + FLOAT_EXPONENT]
    sub a, 0x8000				; remove bias

	set b, [j + FLOAT_EXPONENT]
    sub b, 0x8000				; remove bias

	set c, a					; calculate sum to c
    add c, b
     
    xor a, c					; does arg1.exp and result.exp have different sign
    xor b, c					; does arg2.exp and result.exp have different sign
    and a, b					; both operands have different sign than sum

	; value for overflow exit
	set b, float_postamble_zero			; assume underflow as default 
	ifg [i + FLOAT_EXPONENT], 0x8000	; if exp>0 then assume overflow
		set b, float_postamble_inf

	ifb a, 0x8000				; finally test overflow
      set pc, b					; and act accordingly

	add c, 0x8001				; restore bias
	set [y + FLOAT_EXPONENT], c	; set exponent

	;---------------------------------------
	; calculate mantissa
	;---------------------------------------

	; reserve stack space for mantissa product
	set c, sp
	sub c, FLOAT_PRECISION + FLOAT_PRECISION

	; init stack space with zero
:float_mul_mantissa_init_loop
	set push, 0
	ifg sp, c
		set pc, float_mul_mantissa_init_loop

	; init variables for multiplication loop
	sti x, x				; advance i and j
	set a, i				; a: f1.exp *
	set b, j				; b: f2.exp *
	add i, FLOAT_PRECISION	; i: f1.lsw *
	add j, FLOAT_PRECISION	; j: f2.lsw *
	add c, FLOAT_PRECISION + FLOAT_PRECISION -1	; c: product.lsw *

:float_mul_words_loop
	set x, [j]
	mul x, [i]

	set y, ex		; store product high
	add [c], x		; add product low
	adx [c+-1], y	; add product high
	set x, ex

	set y, c		; y: product current word
	sub y, 2
:float_mul_carry_loop
	ife x, 0
		set pc, float_mul_carry_break
	add [y], x
	set x, ex	
	sub y, 1
	set pc, float_mul_carry_loop

:float_mul_carry_break
	sub j, 1		; move f2 towards msw
	sub c, 1		; move product cword towards msw

	ifn j, b		; if f2 cword not out of bounds
		set pc, float_mul_words_loop

	add j, FLOAT_PRECISION		; set f2 cword back to lsw
	add c, FLOAT_PRECISION		; move product cword back the same amount
	
	sub i, 1		; move f1 cwords towards msw
	sub c, 1		; move product cword towards msw
	
	ifn i, a		; if f1 cword not out of bounds
		set pc, float_mul_words_loop

	; all multiplications done here
	set x, [z-1]
	set y, [x]

	ifb [sp], 0x8000
		set pc, float_mul_finish

	sub [y + FLOAT_EXPONENT], 1

	set c, sp
	add c, FLOAT_PRECISION + FLOAT_PRECISION - 1
	set i, sp

:float_mul_shift_loop
	shl [i], 1
	ifg i, sp
		bor [i-1], ex
	
	ifl i, c
		sti pc, float_mul_shift_loop

:float_mul_finish
	set i, y
	add i, FLOAT_MANTISSA

	set c, i
	add c, FLOAT_PRECISION - 1
	
:float_mul_copy_loop
	set [i], pop
	ifl i, c
		sti pc, float_mul_copy_loop

	set pc, postamble
;----------------------------------------------------------------
; struct handle *float_div(struct handle *f1, struct handle *f2)
;----------------------------------------------------------------
:float_div
	set push, 2
	set push, 3
	jsr preamble

	set i, [z+11]	; struct handle *divident
	set j, [z+10]	; struct handle *divisor

	;---------------------------------------
	; check special cases
	;---------------------------------------
	set a, [i]		; struct float *divident
	set a, [a + FLOAT_CATEGORY]

	set b, [j]		; struct float *divisor
	set b, [b + FLOAT_CATEGORY]

	; arg1 or arg2 is nan	
	ife a, FLOAT_CATEGORY_NAN
		set pc, float_postamble_nan
	ife b, FLOAT_CATEGORY_NAN
		set pc, float_postamble_nan

	; arg1 and arg2 are zeros
	ifb a, FLOAT_CATEGORY_PZERO + FLOAT_CATEGORY_NZERO
		ifb b, FLOAT_CATEGORY_PZERO + FLOAT_CATEGORY_NZERO
			set pc, float_postamble_nan

	; arg1 and arg2 are infs
	ifb a, FLOAT_CATEGORY_PINF + FLOAT_CATEGORY_NINF
		ifb b, FLOAT_CATEGORY_PINF + FLOAT_CATEGORY_NINF
			set pc, float_postamble_nan

	; allocate memory for quotient
	set push, SIZEOF_FLOAT
	set push, TYPE_FLOAT
	jsr alloc
	set [z-1], x	; struct handle *quotient
	set y, [x]		; struct float *quotient

	set i, [i]		; struct float *divident
	set j, [j]		; struct float *divisor

	; simplify detection of following special cases
	set c, a
	bor c, b

	; deduce quotient sign
	set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_PNUM
	ifb c, FLOAT_MASK_POSITIVE
		ifb c, FLOAT_MASK_NEGATIVE
			set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NNUM

	; if divident is inf, quotient is inf with deduced sign
	ifb a, FLOAT_CATEGORY_NINF + FLOAT_CATEGORY_PINF
		set pc, float_postamble_inf
			
	; if divident is zero, quotient is zero with deduced sign
	ifb a, FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
		set pc, float_postamble_zero

	; if divisor is inf, quotient is zero with deduced sign
	ifb b, FLOAT_CATEGORY_NINF + FLOAT_CATEGORY_PINF
		set pc, float_postamble_zero
			
	; if divisor is zero, quotient is inf with deduced sign
	ifb b, FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
		set pc, float_postamble_inf

	;---------------------------------------
	; calculate exponent
	;---------------------------------------
	; is all this really needed to detect overflow?
	; ...does this even work?
    set a, [i + FLOAT_EXPONENT]	; divident exponent
    sub a, 0x8000				; remove bias

	set b, [j + FLOAT_EXPONENT]	; divisor exponent
    sub b, 0x8000				; remove bias

	set c, a					; quotient.exp = divident.exp - divisor.exp
	sub c, b

	; signed arithmetic overflow test
	; c = a + b -> "((a ^ c) & (b ^ c)) < 0"
	xor b, a
	xor a, c
	and a, b

	; prepare for overflow exit
	set x, float_postamble_zero
	ifg [i + FLOAT_EXPONENT], 0x8000
		set x, float_postamble_inf

	ifb a, 0x8000				; finally test overflow
		set pc, x

	add c, 0x8000				; restore bias
	set [y + FLOAT_EXPONENT], c	; set quotient exponent

	set push, [z+11]			; clone divident (because we need to modify it)
	jsr float_clone
	set [z-2], x

	;---------------------------------------
	; calculate mantissa
	;---------------------------------------
	; z-1 -> quotient (y)
	; z-2 -> divident
	; z+10 -> divisor

	; c: quotient.mantissa.cur_word
	; y: quotient.mantissa.lsw
	set c, y
	add c, FLOAT_MANTISSA
	add y, FLOAT_MANTISSA + FLOAT_PRECISION -1
	
	set x, 0						; current word number
	set [c], 1						; set sentinel
:float_div_check_subtract
	set i, [z-2]					; i: struct handle *divident
	set i, [i]						; i: struct float *divident
	add i, FLOAT_MANTISSA           ; i: divident.mantissa.msw *
	
	set a, i
	add a, FLOAT_PRECISION - 1      ; a: divident.mantissa.lsw *
	
	set j, [z+10]					; struct handle *divisor
	set j, [j]						; struct float *divisor
	add j, FLOAT_MANTISSA           ; j: divisor.mantissa.msw

	set x, TRUE
	
:float_div_check_subtract_loop        ; im sooo proud of this loop ;-)
	ife [i], [j]
        ifl i, a
		    sti pc, float_div_check_subtract_loop
	
	ifl [i], [j]
        set x, FALSE
	
:float_div_next_bit
	shl [c], 1
	bor [c], x
	
	ife 0, ex						; no sentinel out
		set pc, float_div_no_word

	add c, 1
	ifg c, y						; all words completed?
		set pc, float_div_normalize ; exit

	set [c], 1						; restrart sentinel

:float_div_no_word
	ife x, FALSE					; skip to shift if subtract is not possible
		set pc, float_div_shift

:float_div_subtract
	set i, [z-2]					; i: struct handle *divident
	set i, [i]						; i: struct float *divident

	set a, i
	add a, FLOAT_MANTISSA           ; a: divident.mantissa.msw

	add i, FLOAT_PRECISION + 1      ; i: divident.mantissa.lsw

	set j, [z+10]					; j: struct handle *divisor
	set j, [j]						; j: struct float *divisor
	add j, FLOAT_PRECISION + 1      ; j: divisor.mantissa.lsw

    set x, 0						; initialize carry
:float_div_subtract_loop
    sub [i], x
    set x, 0
    ifn ex, 0
        set x, 1

	sub [i], [j]
    ifn ex, 0
        set x, 1
    
	ifg i, a
		std pc, float_div_subtract_loop	

:float_div_shift
	set i, [z-2]					; i: struct handle *divident
	set i, [i]						; i: struct float *divident

	set a, i
	add a, FLOAT_MANTISSA           ; a: divident.mantissa.msw

	add i, FLOAT_PRECISION + 1      ; i: divident.mantissa.lsw
	set x, 0

:float_div_shift_loop
	shl [i], 1
    bor [i], x
    set x, ex

    ifg i, a
        std pc, float_div_shift_loop

	ife x, 1
		set pc, float_div_next_bit

	ifb [i], 0x8000
		set pc, float_div_check_subtract

	set pc, float_div_next_bit
	
:float_div_normalize
	set a, [z-1]			; struct handle *quotient
	set b, [a]				; struct float *quotient
	set c, b
	add c, FLOAT_MANTISSA	; quotient.msw
	set i, c				; quotient.msw

:float_div_normalize_loop
	ifb [c], 0x8000
		set pc, float_postamble

	ife [b + FLOAT_EXPONENT], 0
		set pc, float_postamble_zero

	add i, FLOAT_PRECISION - 1	; quotient.lsw
	set x, 0

:float_div_normalize_shift_loop
	shl [i], 1
    bor [i], x
    set x, ex

    ifg i, c
        std pc, float_div_normalize_shift_loop

	sub [b + FLOAT_EXPONENT], 1

	set pc, float_div_normalize_loop

;----------------------------------------------------------------
; struct handle *float_negate(struct handle *f)
;----------------------------------------------------------------
:float_negate
	set push, 1
	set push, 0
	jsr preamble
	
:float_negate_abs_merge
	set push, [z+10]
	jsr float_clone

	; negate
	set y, [x]
	shl [y + FLOAT_CATEGORY], 8
	bor [y + FLOAT_CATEGORY], ex
	
	set pc, postamble

;----------------------------------------------------------------
; struct handle *float_abs(struct handle *f)
;----------------------------------------------------------------
:float_abs
	set push, 1
	set push, 0
	jsr preamble
	
	; return if positive or nan
	set x, [z+10]
	set y, [x]
	ifc [y + FLOAT_CATEGORY], FLOAT_MASK_NEGATIVE
		set pc, postamble

	set pc, float_negate_abs_merge

;----------------------------------------------------------------
; struct handle *float_from_int(struct handle *int)
;----------------------------------------------------------------
:float_from_int
	set push, 1
	set push, 2
	jsr preamble

	; postamble if int is 0
	set a, [z+10]
	set a, [a]

	ife [a], 1
		ife [a+1], 0
			set pc, float_postamble_pzero

	; reserve space for new float
	set push, SIZEOF_FLOAT
	set push, TYPE_FLOAT
	jsr alloc
	set [z-1], x

	; abs
	set push, [z+10]
	jsr int_abs
	set [z-2], x

	set y, [z-1]		; struct handle *float
	set y, [y]			; struct float *

	; set sign
	set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_PNUM
	ifn [z+10], x
		set [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NNUM

	; z-2 is a positive number
	; calculate exp before normalization
	set a, [x]	; struct int *
	set a, [a]	; int size
	shl a, 4	; x16
	add a, 0x7fff
		
	; get amount of bit shifting for normalization
	set x, [x]		; struct int *
	set x, [x+1] 	; msw
	jsr float_msb
	set c, x

	; calculate final exp
	sub a, x
	set [y + FLOAT_EXPONENT], a

	set i, [z-2]	; struct handle *int
	set i, [i]		; struct int *
	set a, i
	add i, 1		; msw
	add a, [a]		; lsw

	add y, FLOAT_MANTISSA		; msw
	set j, y					; msw
	set b, y
	add b, FLOAT_PRECISION - 1	; lsw

:float_from_int_loop
	set [j], [i]				; copy word from int to float
	ifg i, a					; if int ptr is past lsw
		set [j], 0				; -> use zero instead
	shl [j], c					; shift this word
	ifg j, y					; bor in the overflow unless we are already in msw
		bor [j-1], ex
	ifl j, b
		sti pc, float_from_int_loop

	ifl i, a
		set pc, float_from_int_tail

	set pc, float_postamble

:float_from_int_tail			; needed if int.len > float.mantissa.len
	set a, [i+1]
	shl a, c
	bor [j], ex

	set pc, float_postamble

;----------------------------------------------------------------
; struct handle *float_to_int(struct handle *f)
;----------------------------------------------------------------
:float_to_int
	set push, 1
	set push, 1
	jsr preamble

	set y, [z+10]				; struct handle *float
	set y, [y]					; struct float *

	ifb [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN + FLOAT_CATEGORY_PINF + FLOAT_CATEGORY_NINF
		jsr recover				; nan or inf cannot be converted into int

	set x, INT_HANDLE_0
	ifb [y + FLOAT_CATEGORY], FLOAT_CATEGORY_NZERO + FLOAT_CATEGORY_PZERO
		set pc, postamble		; +-0 is just 0

	set a, [y + FLOAT_EXPONENT]	; a = float.exp
	ifg 0x8000, a				; if float < 1
		set pc, postamble		;   return 0

	sub a, 0x8000
	shr a, 4					; div a, 16
	add a, 1					; a = number of words required by int representation

	set b, a					; b = amount of bit shifting required
	shl b, 4		            ; mul a, 16
	add b, 0x7fff
	sub b, [y + FLOAT_EXPONENT]	; shift amount

    ; allocate space for result int
	set push, a
	set push, TYPE_INT
	jsr array_create
	set [z-1], x

	set i, [z+10]               ; struct handle *float
	set i, [i]                  ; struct float *
	add i, FLOAT_MANTISSA       ; float.mantissa.msw
	set c, i                    ; float.mantissa.msw
	add c, FLOAT_PRECISION - 1  ; float.mantissa.lsw

	set j, [x]                  ; struct int *
	set [j], a                  ; set sizeof this int
	add a, j					; int.lsw
	add j, 1                    ; int.msw
	set y, 0

:float_to_int_loop
    set [j], [i]
    shr [j], b
    bor [j], y
    set y, ex

	ifl i, c
        ifl j, a
        	sti pc, float_to_int_loop
    
	set y, [z+10]
	set y, [y]
	ifc FLOAT_MASK_NEGATIVE, [y + FLOAT_CATEGORY]
		set pc, postamble
		
	set push, x
	jsr int_negate
	
	set pc, postamble

;----------------------------------------------------------------
; uint float_to_uint(struct handle *float)
;----------------------------------------------------------------
:float_to_uint
	set push, 1
	set push, 1
	jsr preamble

	set push, [z+10]
	jsr float_to_int
	set [z-1], x
	
	set push, x
	jsr int_to_int16	;int_to_uint
	
	set pc, postamble

;----------------------------------------------------------------
; struct handle *float_from_uint(uint i)
;----------------------------------------------------------------
:float_from_uint
	set push, 1
	set push, 1
	jsr preamble
	
	set push, [z+10]
	jsr uint16_to_int	;int_from_uint
	set [z-1], x
	
	set push, [z-1]
	jsr float_from_int
	
	set pc, postamble

;----------------------------------------------------------------
; struct handle *float_from_str(struct handle *str)
;----------------------------------------------------------------
#define FP_STATE_START			1
#define FP_STATE_SIGN			2
#define FP_STATE_DIGIT_WHOLE	4
#define FP_STATE_DECIMAL_POINT	8
#define FP_STATE_DIGIT_DECIMAL	16
#define FP_STATE_E				32
#define FP_STATE_EXPONENT_SIGN	64
#define FP_STATE_EXPONENT_DIGIT	128

#define FPV_EXPONENT_NEGATIVE	-2
#define FPV_EXPONENT			-3
#define FPV_EXPONENT_MODIFIER	-4
#define FPV_STATE				-5

:float_from_str
	set push, 1			; sizeof(args)
	set push, 1			; sizeof(refs)
	jsr preamble

	set a, [z+10]		; struct handle *str

	;---------------------------------------
	; handle nan and infinities
	;---------------------------------------
	set b, [a]			; struct string *
	set c, [b]			; str.len
	
	ifg c, 2
		ife [b+1], 'i'
			ife [b+2], 'n'
				ife [b+3], 'f'
					set pc, float_postamble_pinf

	ifg c, 2
		ife [b+1], 'n'
			ife [b+2], 'a'
				ife [b+3], 'n'
					set pc, float_postamble_nan

	ifg c, 3
		ife [b+1], '-'
			ife [b+2], 'i'
				ife [b+3], 'n'
					ife [b+4], 'f'
						set pc, float_postamble_ninf				

	ifg c, 3
		ife [b+1], '+'
			ife [b+2], 'i'
				ife [b+3], 'n'
					ife [b+4], 'f'
						set pc, float_postamble_pinf

	;---------------------------------------
	; handle numbers
	;---------------------------------------
	set [z-1], [FLOAT_PZERO]

	set push, FALSE				; FPV_EXPONENT_NEGATIVE
	set push, 0					; FPV_EXPONENT
	set push, 0					; FPV_EXPONENT_MODIFIER
	set push, FP_STATE_START	; FPV_STATE

	set b, 0					; index in str

:ffs_loop
	jsr array_get
	add b, 1
	set c, x

	ife c, '+'
		set pc, ffs_plus
	ife c, '-'
		set pc, ffs_minus
	ife c, 'e'
		set pc, ffs_exponent
	ife c, 'E'
		set pc, ffs_exponent
	ife c, '.'
		set pc, ffs_decimal_point

	ifg c, '9'						; not a number?
		set pc, ffs_end
	ifl c, '0'						; not a number?
		set pc, ffs_end

	sub c, '0'						; convert char to int

	ifb [z + FPV_STATE], FP_STATE_E + FP_STATE_EXPONENT_SIGN
		set pc, ffs_exponent_number
	ifb [z + FPV_STATE], FP_STATE_DIGIT_DECIMAL + FP_STATE_DECIMAL_POINT	; if in fraction part
		set pc, ffs_fraction
	ifb [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE	; if in whole number part
		set pc, ffs_whole_number

	set pc, ffs_end				; wrong state for a number

:ffs_fraction
	; parse digit to fraction
	set [z + FPV_STATE], FP_STATE_DIGIT_DECIMAL						; set state
	
;	ife [z + FPV_NUM_SIGNIFICANTS], 5		; ignore non-significant decimals 
;		set pc, ffs_loop
	
	sub [z + FPV_EXPONENT_MODIFIER], 1
	set pc, ffs_add_significant

:ffs_whole_number
	set [z + FPV_STATE], FP_STATE_DIGIT_WHOLE							; set state

	; ignore leading zeros
;	ife c, 0									; curchar = '0'
;		ife [z + FPV_NUM_SIGNIFICANTS], 0
;			set pc, ffs_loop

;	ife [z + FPV_NUM_SIGNIFICANTS], 5
;		set pc, ffs_significant_full

:ffs_add_significant
	set push, [z-1]
	set push, [FLOAT_10]
	jsr float_mul
	set [z-1], x

	set push, [z-1]
	set push, [FLOAT_0 + c]
	jsr float_add
	set [z-1], x

	set pc, ffs_loop

:ffs_exponent_number
	set [z + FPV_STATE], FP_STATE_EXPONENT_DIGIT	; set state

	mul [z + FPV_EXPONENT], 10
	ifn ex, 0
		set pc, ffs_overflow
		
	add [z + FPV_EXPONENT], c
	ifn ex, 0
		set pc, ffs_overflow

	set pc, ffs_loop

:ffs_overflow
	ife [z + FPV_EXPONENT_NEGATIVE], TRUE
		set pc, float_postamble_zero
	set pc, float_postamble_inf

:ffs_minus
	ifb [z + FPV_STATE], FP_STATE_START
		set pc, ffs_mantissa_minus
	ifb [z + FPV_STATE], FP_STATE_E
		set pc, ffs_exponent_minus
	set pc, ffs_end
:ffs_mantissa_minus
	; handle leading minus
	set [z + FPV_STATE], FP_STATE_SIGN
	
	set push, [z-1]
	jsr float_negate
	set [z-1], x

	set pc, ffs_loop
:ffs_exponent_minus
	set [z + FPV_STATE], FP_STATE_EXPONENT_SIGN
	set [z + FPV_EXPONENT_NEGATIVE], TRUE
	set pc, ffs_loop
	
:ffs_plus
	ifb [z + FPV_STATE], FP_STATE_START
		set [z + FPV_STATE], FP_STATE_SIGN
	ifb [z + FPV_STATE], FP_STATE_E
		set [z + FPV_STATE], FP_STATE_EXPONENT_SIGN
	set pc, ffs_end
	
:ffs_decimal_point
	ifc [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE
		set pc, ffs_end

	set [z + FPV_STATE], FP_STATE_DECIMAL_POINT
	set pc, ffs_loop
	
:ffs_exponent
	ifc [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_DIGIT_WHOLE + FP_STATE_DIGIT_DECIMAL
		set pc, ffs_end
	set [z + FPV_STATE], FP_STATE_E
	set pc, ffs_loop

:ffs_end
	ifb [z + FPV_STATE], FP_STATE_START + FP_STATE_SIGN + FP_STATE_E + FP_STATE_EXPONENT_SIGN
		jsr recover

	set ex, 0
	ife [z + FPV_EXPONENT_NEGATIVE], FALSE
		add [z + FPV_EXPONENT], 0x8000

	ifn ex, 0
		set pc, ffs_overflow

	add [z + FPV_EXPONENT], [z + FPV_EXPONENT_MODIFIER]
	ifb [z + FPV_EXPONENT_MODIFIER], 0x8000
		ife ex, 0
			set pc, ffs_overflow
	ifc [z + FPV_EXPONENT_MODIFIER], 0x8000
		ifn ex, 0
			set pc, ffs_overflow
	
	set a, float_mul
	set b, -1
	ifg [z + FPV_EXPONENT], 0x8000
		set pc, ffs_scale_loop
		
	set a, float_div
	set b, 1

:ffs_scale_loop
	ife [z + FPV_EXPONENT], 0x8000
		set pc, float_postamble

	set push, [z-1]
	set push, [FLOAT_10]
	jsr a
	set [z-1], x

	add [z + FPV_EXPONENT], b
	set pc, ffs_scale_loop

;----------------------------------------------------------------
; struct handle *float_to_str(struct handle *f)
;----------------------------------------------------------------
:float_to_str
	set push, 1			; number of arguments
	set push, 2			; amount of local variable space
	jsr preamble

	set i, [z+10]
	set i, [i]

	set x, 0
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NAN
		set x, STR_NAN
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_PINF
		set x, STR_PINF
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NINF
		set x, STR_NINF
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_NZERO
		set x, STR_NZERO
	ife [i + FLOAT_CATEGORY], FLOAT_CATEGORY_PZERO
		set x, STR_PZERO
	ifn x, 0
		set pc, postamble

	set push, 13
	set push, TYPE_STRING
	jsr alloc
	set [z-1], x

	set push, [z+10]
	jsr float_abs
	set [z-2], x
	
	set a, 1		; a: magnitude
	set b, 0		; b: significants
	
	ife [z+10], [z-2]
		set pc, fts_scale_down

	set push, [z-1]
	set push, -1
	set push, '-'
	jsr array_insert
	
:fts_scale_down
	set push, [z-2]
	set push, [FLOAT_10]
	jsr float_cmp

	ife x, -1
		set pc, fts_print

	set push, [z-2]
	set push, [FLOAT_10]
	jsr float_div
	set [z-2], x
	
	add a, 1
	set pc, fts_scale_down

:fts_print
	set push, [z-2]
	jsr float_to_uint
	set c, x
	add x, '0'			; change number to character

	set push, [z-1]		; add character to string
	set push, -1
	set push, x
	jsr array_insert

	set push, [z-2]
	set push, [FLOAT_0 + c]
	jsr float_sub
	set [z-2], x

;	ife [MASK+i], MASK_ZERO
;		set pc, ftoa_fill_with_zero

	bor c, b
	ife c, 0
		set pc, fts_scale_up

	add b, 1
	ife b, 9
		set pc, fts_fill_with_zero

:fts_scale_up
	set push, [z-2]
	set push, [FLOAT_10]
	jsr float_mul
	set [z-2], x
	
	sub a, 1
	ifn a, 0
		set pc, fts_print

	set push, [z-1]		; add character to string
	set push, -1
	set push, '.'
	jsr array_insert
	
	set pc, fts_print

:fts_fill_with_zero
	sub a, 1
	ife a, 0
		set pc, fts_finish
	ifb a, 0x8000
		set pc, fts_finish
		
	set push, [z-1]		; add character to string
	set push, -1
	set push, '0'
	jsr array_insert
	
	set pc, fts_fill_with_zero

:fts_finish
	set x, [z-1]
	set pc, postamble

;----------------------------------------------------------------
; HELPER SUBROUTINES
;----------------------------------------------------------------

;----------------------------------------------------------------
:float_postamble
; copy float from stack to heap and return from subroutine
;----------------------------------------------------------------
	set x, [z-1]	
	set pc, postamble

;----------------------------------------------------------------
:float_postamble_zero
;----------------------------------------------------------------
	set y, [z-1]
	set y, [y]
	
	set x, [FLOAT_PZERO]
	ifb [y + FLOAT_CATEGORY], FLOAT_MASK_NEGATIVE
		set x, [FLOAT_NZERO]

	set pc, postamble

;----------------------------------------------------------------
:float_postamble_inf
;----------------------------------------------------------------
	set y, [z-1]
	set y, [y]
	
	set x, [FLOAT_PINF]
	ifb [y + FLOAT_CATEGORY], FLOAT_MASK_NEGATIVE
		set x, [FLOAT_NINF]

	set pc, postamble

;----------------------------------------------------------------
:float_postamble_nzero
;----------------------------------------------------------------
	set x, [FLOAT_NZERO]
	set pc, postamble

;----------------------------------------------------------------
:float_postamble_pzero
;----------------------------------------------------------------
	set x, [FLOAT_PZERO]
	set pc, postamble

;----------------------------------------------------------------
:float_postamble_pinf
;----------------------------------------------------------------
	set x, [FLOAT_PINF]
	set pc, postamble

;----------------------------------------------------------------
:float_postamble_ninf
;----------------------------------------------------------------
	set x, [FLOAT_NINF]
	set pc, postamble

;----------------------------------------------------------------
:float_postamble_nan
;----------------------------------------------------------------
	set x, [FLOAT_NAN]
	set pc, postamble
	
;----------------------------------------------------------------
; struct handle *float_normalize(struct handle *dnf)
;----------------------------------------------------------------
:float_normalize
	set push, 1
	set push, 0
	jsr preamble

	set a, [z+10]				; struct handle *
	set a, [a]					; struct float *

	set b, a					; struct float *
	add b, FLOAT_MANTISSA		; float.mantissa.msw

	set c, b
	add c, FLOAT_PRECISION - 1	; float.mantissa.lsw
	
	set i, b					; float.mantissa.msw

; start from msw and search for 1st non-zero word
:float_normalize_search_word
	; exit loop if non-zero found
	ifn [i], 0
		set pc, float_normalize_found_word

	; for each zero word, add (or sub?) exponent by 16
	sub [a + FLOAT_EXPONENT], 16

	; continue loop if not yet lsw	
	ifl i, c
		sti pc, float_normalize_search_word

	; return zero
	set pc, float_postamble_zero

:float_normalize_found_word
	set j, b					; float.mantissa.msw
	set x, 0
	set y, [i]					; value of 1st non-zero word

; calclate how many bits need to be shifted until msb is 1
:float_normalize_search_bit
	ifb y, 0x8000
		set pc, float_normalize_shift
		
	shl y, 1
	add x, 1
	
	set pc, float_normalize_search_bit

; the real work, copy and shift
; facts:
;  - j points to msw
;  - i points to 1st non-zero word
;  - x is the amount of bit shifting
;  - b points to msw
;  - c points to lsw
;  - we know this is not zero
:float_normalize_shift
	; copy from i to j
	set [j], [i]
	
	; if i is past lsw, overwrite j with 0
	ifg i, c
		set [j], 0

	; do the bit shifting
	shl [j], x
	
	; if j is past msw, merge outshifted bits to previous word
	ifg j, b
		bor [j-1], ex
	
	ifl j, c
		sti pc, float_normalize_shift

	sub [a + FLOAT_EXPONENT], x
	set x, [z+10]
	set pc, postamble

;----------------------------------------------------------------
:float_msb
; fastcall
;  x: number
; return
;  x: msb distance from bit 15
;----------------------------------------------------------------
	ifn x, 0
		set pc, float_msb_shift
	set x, 16
	set pc, pop

:float_msb_shift
	set push, x
    sub x, x

:float_msb_loop
	shl [sp], 1
	ifn ex, 0
		set pc, float_msb_exit
	add x, 1
	set pc, float_msb_loop	

:float_msb_exit
    add sp, 1
    
    set pc, pop

;----------------------------------------------------------------
; uint float_to_uint(struct handle *float)
;----------------------------------------------------------------
:float_random
	set push, 2
	set push, 2
	jsr preamble
	
	set push, SIZEOF_FLOAT
	set push, TYPE_FLOAT
	jsr alloc
	set [z-1], x

	set c, [x]
	add c, FLOAT_MANTISSA + FLOAT_PRECISION

	set i, [x]
	sti [i], FLOAT_CATEGORY_PNUM
	sti [i], 0x8000

:float_random_loop
	jsr int_rnd_lfsr
	sti [i], x
	ifl i, c
		set pc, float_random_loop
	
	bor [c - FLOAT_PRECISION], 0x8000
	
	; transpose 1.0-2.0 to 0.0-1.0	
	set push, [z-1]
	set push, [FLOAT_1]
	jsr float_sub
	set [z-1], x

	; scaling factor
	set push, [z+10]
	set push, [z+11]
	jsr float_sub
	set [z-2], x

	; scale
	set push, [z-1]
	set push, [z-2]
	jsr float_mul
	set [z-1], x

	; transpose
	set push, [z-1]
	set push, [z+11]
	jsr float_add

	set pc, postamble

;----------------------------------------------------------------
; uint float_pow(struct handle *float, struct handle *int)
;----------------------------------------------------------------
:float_pow
	set push, 2
	set push, 2
	jsr preamble

	set push, [z+10]
	jsr int_sgn
	set a, x
	
	set x, [FLOAT_1]
	ife a, 0
		set pc, postamble

	set x, [FLOAT_0]
	ife a, -1
		set pc, postamble

	set push, [z+10]
	jsr int_to_int16
	set c, x

	set [z+-1], [z+11] 			; p
	set [z+-2], [FLOAT_1]		; r
	
:float_pow_loop
	ife c, 0
		set pc, float_pow_break

	ifc c, 1
		set pc, float_pow_skip
		
	set push, [z+-2]
	set push, [z+-1]
	jsr float_mul
	set [z+-2], x
	
:float_pow_skip
	set push, [z+-1]
	set push, [z+-1]
	jsr float_mul
	set [z+-1], x

	div c, 2
	set pc, float_pow_loop

:float_pow_break
	set x, [z+-2]
	set pc, postamble	
