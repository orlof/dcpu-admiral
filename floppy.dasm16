; admiral functions
; format()
; dict dir()
; save(str, item)
; item load(str)
; del(str)

; these defines are only foor mbr
#define FLOPPY__MBR__SECTOR				0x00
#define FLOPPY__MBR__HEAD_SECTOR		MEM_FLOPPY_START
#define FLOPPY__MBR__TAIL_SECTOR		MEM_FLOPPY_START + 1
#define FLOPPY__MBR__DIR_SECTOR			MEM_FLOPPY_START + 2

; all other sectors
#define FLOPPY__SECTOR__NEXT_SECTOR		MEM_FLOPPY_START
#define FLOPPY__SECTOR__DATA_START		MEM_FLOPPY_START + 1

#define FLOPPY__STATE__BUSY				0x03

#define INODE_SECTOR					1
#define INODE_SIZE						2

;----------------------------------------------------------------
; extern void file__format()
;----------------------------------------------------------------
:floppy__format
	set push, 0
	set push, 1
	jsr preamble

	;---------------------------------------
	; initialize all sectors
	;---------------------------------------
	set [FLOPPY__MBR__TAIL_SECTOR], 1439
	set [FLOPPY__MBR__DIR_SECTOR], 1

	set i, 0
:floppy__format__next_sector
	sti [floppy__sector__current], i
	ife i, 1440
		set i, 0
	set [FLOPPY__SECTOR__NEXT_SECTOR], i
	
	jsr floppy__sector__write

	ifn i, 0
		set pc, floppy__format__next_sector

	;---------------------------------------
	; create empty dir
	;---------------------------------------
	set push, 0
	set push, TYPE_DICT
	jsr array_create
	set [z-1], x

	set push, 1
	jsr floppy__file__open
	
	set push, [z-1]
	jsr floppy__item__serialize
	
	jsr floppy__file__close

	set pc, postamble
	
;----------------------------------------------------------------
; extern struct handle *file__dir__read(void)
; return {} dir
; reads the directory from floppy
;----------------------------------------------------------------
:floppy__dir__read
	;---------------------------------------
	; read mbr
	;---------------------------------------
	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read

	;---------------------------------------
	; read directory
	;---------------------------------------
	set push, [FLOPPY__MBR__DIR_SECTOR]
	jsr floppy__item__read_from_sector

	set pc, pop

;----------------------------------------------------------------
; extern struct handle *floppy__item__read(struct handle *inode)
;----------------------------------------------------------------
:floppy__item__read
    set push, 1
    set push, 0
    jsr preamble

	set x, [z+10]		; struct handle *tuple
	set x, [x]			; struct inode *

	set push, [x + INODE__SECTOR]
	jsr int_to_int16

	set push, x
	jsr floppy__item__read_from_sector
	
	set pc, postamble

;----------------------------------------------------------------
; extern void save(struct handle *filename, struct handle *item)
;----------------------------------------------------------------
:floppy__item__write
    set push, 2
    set push, 2
    jsr preamble

	;---------------------------------------
	; store item to disk
	;---------------------------------------
	set push, [z+10]
	jsr floppy__item__write_to_free_space
	set [z-1], x							; inode
	
	;---------------------------------------
	; update directory
	;---------------------------------------
	jsr floppy__dir__read
	set [z-2], x
	
	set push, x
	set push, [z+11]
	jsr dict_get
	
	ife x, 0
		set pc, floppy__item__write__update_dir

	set x, [x]
	set push, [x + INODE_SECTOR]
	jsr floppy__sector__free

:floppy__item__write__update_dir
	set push, [z-2]
	set push, [z+11]
	set push, [z-1]
	jsr dict_set

	set push, [z-2]
	jsr floppy__dir__write

    set pc, postamble    

;----------------------------------------------------------------
; struct handle *file__delete(struct handle *filename)
;----------------------------------------------------------------
:floppy__file__delete
    set push, 1
    set push, 2
    jsr preamble

	;---------------------------------------
	; update directory
	;---------------------------------------
	jsr floppy__dir__read
	set [z-1], x
	
	set push, x
	set push, [z+11]
	jsr dict_del
	set [z-2], x			; struct handle *tuple

	ife x, 0
		set pc, postamble

	;---------------------------------------
	; free space
	;---------------------------------------
	set x, [x]				; struct tuple *kv
	set x, [x + DICT_ITEM_VALUE]	; struct handle *inode
	set x, [x]				; struct inode *
	set push, [x + INODE_SECTOR]
	jsr floppy__sector__free
	
	set pc, postamble

;----------------------------------------------------------------
; void file__dir__write(struct handle *dir)
;----------------------------------------------------------------
:floppy__dir__write
	set push, 1
	set push, 1
	jsr preamble
	
	set push, [z+10]
	jsr floppy__item__write_to_free_space
	set [z-1], x							; inode

	; get first_sector
	set x, [x]
	set push, [x + INODE__SECTOR]
	jsr int_to_int16
	set a, x

	; read mbr
	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read
	
	; update dir location
	set [FLOPPY__MBR__DIR_SECTOR], a

	; write mbr
	jsr floppy__sector__write

	set pc, postamble

;----------------------------------------------------------------
; struct handle *file__deserialize(void)
;----------------------------------------------------------------
:floppy__item__deserialize
    set push, 0
    set push, 0
    jsr preamble
    
    set pc, recover
    set pc, postamble

;----------------------------------------------------------------
; void file__serialize(struct handle *item)
;----------------------------------------------------------------
:floppy__item__serialize
    set push, 1
    set push, 0
    jsr preamble

    set a, sp					; done.end
    set b, sp

    set push, [z+10]			; put root item to queue

:file__serialize__next_item
	sub b, 1					; take next item in fifo order

	;---------------------------------------
	; write ID
	;---------------------------------------
	set y, [b]					; id == struct handle *
    set push, y
    jsr floppy__file__write_word

	;---------------------------------------
	; write TYPE
	;---------------------------------------
	set c, [y + HANDLE_TYPE]
    set push, c 				; type
    jsr floppy__file__write_word

	;---------------------------------------
	; write SIZE (actual)
	;---------------------------------------
    set y, [y]                  ; move y to data
 
	set j, [y]					; array size
    ife c, TYPE_FLOAT			; if item is float
	    set j, SIZEOF_FLOAT		; float size

	set push, j
    jsr floppy__file__write_word

	;---------------------------------------
	; write DATA
	;---------------------------------------
    set i, y
    ifn c, TYPE_FLOAT
    	add i, 1
    
    add y, j

:file__serialize__data__loop
	ifg i, y					
		ifl sp, b
			set pc, file__serialize__next_item

	ifg i, y
		set pc, postamble

	set push, [i]
	jsr floppy__file__write_word

	ifc c, TYPE_GROUP_CONTAINER
		sti pc, file__serialize__data__loop

; here starts the todo insertion loop
    set j, a

:file__serialize__search_item
	sub j, 1
    ife [j], [i]		; match
    	sti pc, file__serialize__data__loop

    ifg j, sp
        set pc, file__serialize__search_item   ; no match

	; no match found
	set push, [i]
	
	sti pc, file__serialize__data__loop
  
;----------------------------------------------------------------
; struct handle *file__item__read_from_sector(uint16 sector)
;----------------------------------------------------------------
:floppy__item__read_from_sector
	set push, 1
	set push, 0
	jsr preamble
	
	set push, [z+10]
	jsr floppy__file__open		

	jsr floppy__item__deserialize
	
	set pc, postamble

;----------------------------------------------------------------
; struct handle *file__write(struct handle *item)
;----------------------------------------------------------------
:floppy__item__write_to_free_space
    set push, 1
    set push, 1
    jsr preamble

	;---------------------------------------
	; read mbr
	;---------------------------------------
	set push, FLOPPY__MBR__SECTOR 
	jsr floppy__sector__read

	set a, [FLOPPY__MBR__HEAD_SECTOR]		; first sector

	;---------------------------------------
	; write file to free space
	;---------------------------------------
	set push, a
	jsr floppy__file__open

	; serialize object
    set push, [z+10]
    jsr floppy__item__serialize

	set b, [floppy__file__position]			; file length

	;---------------------------------------
	; terminate file and update list of free sectors
	;---------------------------------------
	jsr floppy__file__close
	
	;---------------------------------------
	; return struct handle *inode (sector, size)
	;---------------------------------------
	set push, 2
	set push, TYPE_TUPLE
	jsr array_create
	set [z-1], x

	set c, [x]

	set push, a					; sector
	jsr uint16_to_int
	set [c + INODE_SECTOR], x
	
	set push, b					; length
	jsr uint16_to_int
	set [c + INODE_SIZE], x

	set pc, postamble

;----------------------------------------------------------------
:floppy__file__open
;----------------------------------------------------------------
	set push, [sp + 1]
    jsr floppy__sector__read

	; initialize file position
    set [floppy__file__position], 0
    
    set [sp], pop
    set pc, pop

;----------------------------------------------------------------
:floppy__file__close
;----------------------------------------------------------------
	; store next free sector
	set push, [FLOPPY__SECTOR__NEXT_SECTOR]

	; terminate current sector list
	set [FLOPPY__SECTOR__NEXT_SECTOR], 0
	jsr floppy__sector__write

	; update mbr
	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read

	set [FLOPPY__MBR__HEAD_SECTOR], pop
	jsr floppy__sector__write
	
	set pc, pop

;----------------------------------------------------------------
; LOW LEVEL SUBROUTINES
;----------------------------------------------------------------

;----------------------------------------------------------------
:floppy__file__write_word
;----------------------------------------------------------------
	ifl [floppy__buffer__position], MEM_FLOPPY_END
        set pc, floppy__file__write_word__to_buffer

    jsr floppy__sector__write

    ; read the next sector to memory buffer
    set push, [FLOPPY__SECTOR__NEXT_SECTOR]
    jsr floppy__sector__read

:floppy__file__write_word__to_buffer
    set x, [floppy__buffer__position]
    set [x], [sp + 1]

    add [floppy__buffer__position], 1
    add [floppy__file__position], 1
    
	set [sp], pop
    set pc, pop

;----------------------------------------------------------------
:floppy__file__read_word
;----------------------------------------------------------------
	ifl [floppy__buffer__position], MEM_FLOPPY_END
        set pc, floppy__file__read_word__from_buffer

    ; read the next sector to memory buffer
    set push, [FLOPPY__SECTOR__NEXT_SECTOR]
    jsr floppy__sector__read

:floppy__file__read_word__from_buffer
    set c, [floppy__buffer__position]
    set c, [c]

    add [floppy__buffer__position], 1
    add [floppy__file__position], 1

    set pc, pop

;----------------------------------------------------------------
; void floppy__sector__write()
;----------------------------------------------------------------
:floppy__sector__write
    set push, 0
    set push, 0
    jsr preamble

	;---------------------------------------
	; initiate write
	;---------------------------------------
	set a, 3
	set x, [floppy__sector__current]
	set y, MEM_FLOPPY_START
	hwi [floppy]
	;---------------------------------------

	jsr floppy__status__wait_ready

    set pc, postamble

;----------------------------------------------------------------
; void file__sector__read(uint16 _sector)
;----------------------------------------------------------------
:floppy__sector__read
    set push, 1
    set push, 0
    jsr preamble
    
	;---------------------------------------
	; initiate read
	;---------------------------------------
	set a, 2					; read from floppy
	set x, [z + 10]				; _sector
	set y, MEM_FLOPPY_START
	hwi [floppy]
	;---------------------------------------
	
	; poll for ready
	jsr floppy__status__wait_ready

	; update current sector
    set [floppy__sector__current], [z + 10]

	; reset buffer pointer
    set [floppy__buffer__position], FLOPPY__SECTOR__DATA_START

    set pc, postamble

;----------------------------------------------------------------
; struct handle *floppy__sector__free(uint16 _sector)
;----------------------------------------------------------------
:floppy__sector__free
    set push, 1
    set push, 0
    jsr preamble

	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read

	set push, [FLOPPY__MBR__TAIL_SECTOR]
	jsr floppy__sector__read

	set [FLOPPY__SECTOR__NEXT_SECTOR], [z + 10]
	jsr floppy__sector__write

	set pc, postamble

;----------------------------------------------------------------
:floppy__status__wait_ready
;----------------------------------------------------------------
	set a, 0
:floppy__status__wait_ready__loop
	hwi [floppy]
	ife b, FLOPPY__STATE__BUSY
		set pc, floppy__status__wait_ready__loop

	set pc, pop
	
