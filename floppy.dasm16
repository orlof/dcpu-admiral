; admiral floppy functions
;  void format(void)
;  item dir(void)
;  item load(filename)
;  void save(filename, item)
;  void del(filename)

; mbr definitions
#define FLOPPY__MBR__SECTOR				0x00
#define FLOPPY__MBR__FREE_HEAD			MEM_FLOPPY_START
#define FLOPPY__MBR__FREE_TAIL			MEM_FLOPPY_START + 1
#define FLOPPY__MBR__DIR_HEAD			MEM_FLOPPY_START + 2
#define FLOPPY__MBR__DIR_TAIL			MEM_FLOPPY_START + 3

; data sector definitions
#define FLOPPY__SECTOR__NEXT			MEM_FLOPPY_START
#define FLOPPY__SECTOR__DATA			MEM_FLOPPY_START + 1

#define FLOPPY__STATE__BUSY				0x03

#define INODE__SECTOR__HEAD				1
#define INODE__SECTOR__TAIL				2
#define INODE__SIZE						3

:floppy__free
:floppy__free__head		DAT				0
:floppy__free__tail		DAT				0

:floppy__dir
:floppy__dir__head		DAT				0
:floppy__dir__tail		DAT				0

;----------------------------------------------------------------
; extern void file__format()
;----------------------------------------------------------------
:floppy__format
	set push, 0
	set push, 1
	jsr preamble

	;---------------------------------------
	; initialize mbr
	;---------------------------------------
	set 

	;---------------------------------------
	; initialize all sectors
	;---------------------------------------
	set [FLOPPY__MBR__TAIL], 1439
	set [FLOPPY__MBR__DIR], 1

	set i, 0
:floppy__format__next_sector
	sti [floppy__sector__current], i
	ife i, 1440
		set i, 0
	set [FLOPPY__SECTOR__NEXT], i
	
	jsr floppy__sector__write

	ifn i, 0
		set pc, floppy__format__next_sector

	;---------------------------------------
	; create empty dir
	;---------------------------------------
	set push, 0
	set push, TYPE_DICT
	jsr array_create
	set [z-1], x

	set push, [z-1]
	jsr floppy__item__serialize
	
	set pc, postamble
	
;----------------------------------------------------------------
; extern struct handle *floppy__dir(void)
;----------------------------------------------------------------
:floppy__dir
	;---------------------------------------
	; read mbr
	;---------------------------------------
	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read

	;---------------------------------------
	; read directory
	;---------------------------------------
	set push, [FLOPPY__MBR__DIR]
	jsr floppy__item__read

	set pc, pop

;----------------------------------------------------------------
; extern struct handle *floppy__load(struct handle *filename)
;----------------------------------------------------------------
:floppy__load
    set push, 1
    set push, 1
    jsr preamble

	; load directory
	jsr floppy__dir
	set [z-1], x

	; get inode by filename
	set push. x
	set push, [z+10]
	jsr dict_get
	set [z-1], x

	ife x, 0
		set pc, floppy__file_not_found

	; get inode.sector
	set x, [x]

	set push, [x + INODE__SECTOR]
	jsr int_to_int16

	set push, x
	jsr floppy__item__read
	
	set pc, postamble

;----------------------------------------------------------------
; extern void save(struct handle *filename, struct handle *item)
;----------------------------------------------------------------
:floppy__save
    set push, 2
    set push, 2
    jsr preamble

	;---------------------------------------
	; store item to disk
	;---------------------------------------
	set push, [z+10]
	jsr floppy__item__write
	set [z-1], x							; inode
	
	;---------------------------------------
	; update directory
	;---------------------------------------
	jsr floppy__dir
	set [z-2], x
	
	set push, x
	set push, [z+11]
	jsr dict_get
	
	ife x, 0
		set pc, floppy__item__save__update_dir

	set x, [x]
	set push, [x + INODE__SECTOR]
	jsr floppy__sector__free

:floppy__item__save__update_dir
	set push, [z-2]
	set push, [z+11]
	set push, [z-1]
	jsr dict_set

	set push, [z-2]
	jsr floppy__dir__write

    set pc, postamble    

;----------------------------------------------------------------
; struct handle *floppy__delete(struct handle *filename)
;----------------------------------------------------------------
:floppy__delete
    set push, 1
    set push, 2
    jsr preamble

	; load directory
	jsr floppy__dir
	set [z-1], x

	; del dict.node by filename
	set push. x
	set push, [z+10]
	jsr dict_del
	set [z-1], x

	ife x, 0
		set pc, floppy__file_not_found

	; write updated directory
	set push, [z-1]
	jsr floppy__item__write	
	set [z-1], x
	set a, [x]
	set a, [a + INODE__SECTOR]
	
	; update directory pointer
	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read

	set [FLOPPY__MBR__DIR], a

	jsr floppy__sector__write

	set x, [x]						; struct inode *
	set push, 
	jsr floppy__sector__free


	
	;---------------------------------------
	; update directory
	;---------------------------------------
	jsr floppy__dir__read
	set [z-1], x
	
	set push, x
	set push, [z+11]
	jsr dict_del
	set [z-2], x			; struct handle *tuple

	ife x, 0
		set pc, postamble

	;---------------------------------------
	; free space
	;---------------------------------------
	set x, [x]				; struct tuple *kv
	set x, [x + DICT_ITEM_VALUE]	; struct handle *inode
	set x, [x]				; struct inode *
	set push, [x + INODE_SECTOR]
	jsr floppy__sector__free
	
	set pc, postamble

;----------------------------------------------------------------
; void file__dir__write(struct handle *dir)
;----------------------------------------------------------------
:floppy__dir__write
	set push, 1
	set push, 1
	jsr preamble
	
	set push, [z+10]
	jsr floppy__item__serialize
	set [z-1], x							; inode

	; get first_sector
	set x, [x]
	set push, [x + INODE__SECTOR]
	jsr int_to_int16
	set a, x

	; read mbr
	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read
	
	; update dir location
	set [FLOPPY__MBR__DIR], a

	; write mbr
	jsr floppy__sector__write

	set pc, postamble

;----------------------------------------------------------------
; struct handle *file__deserialize(void)
;----------------------------------------------------------------
:floppy__deserialize
    set push, 0
    set push, 0
    jsr preamble
    
    set pc, recover
    set pc, postamble

;----------------------------------------------------------------
; struct handle *file__serialize(struct handle *item)
;----------------------------------------------------------------
:floppy__serialize
    set push, 1
    set push, 1
    jsr preamble

	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read

	set push, [FLOPPY__MBR__HEAD]
	jsr floppy__file__open
	
    set a, sp					; done.end
    set b, sp

    set push, [z+10]			; put root item to queue

:file__serialize__next_item
	sub b, 1					; take next item in fifo order

	;---------------------------------------
	; write ID
	;---------------------------------------
	set y, [b]					; id == struct handle *
    set push, y
    jsr floppy__file__write_word

	;---------------------------------------
	; write TYPE
	;---------------------------------------
	set c, [y + HANDLE_TYPE]
    set push, c 				; type
    jsr floppy__file__write_word

	;---------------------------------------
	; write SIZE (actual)
	;---------------------------------------
    set y, [y]                  ; move y to data
 
	set j, [y]					; array size
    ife c, TYPE_FLOAT			; if item is float
	    set j, SIZEOF_FLOAT		; float size

	set push, j
    jsr floppy__file__write_word

	;---------------------------------------
	; write DATA
	;---------------------------------------
    set i, y
    ifn c, TYPE_FLOAT
    	add i, 1
    
    add y, j

:file__serialize__data__loop
	ifg i, y					
		ifl sp, b
			set pc, file__serialize__next_item

	ifg i, y
		set pc, floppy__item__serialize_finalize

	set push, [i]
	jsr floppy__file__write_word

	ifc c, TYPE_GROUP_CONTAINER
		sti pc, file__serialize__data__loop

; here starts the todo insertion loop
    set j, a

:file__serialize__search_item
	sub j, 1
    ife [j], [i]		; match
    	sti pc, file__serialize__data__loop

    ifg j, sp
        set pc, file__serialize__search_item	; no match

	; no match found
	set push, [i]
	
	sti pc, file__serialize__data__loop

:floppy__item__serialize_finalize
	; store next free sector
	set a, [FLOPPY__SECTOR__NEXT]

	; terminate current sector list
	set [FLOPPY__SECTOR__NEXT], 0
	jsr floppy__sector__write

	; update mbr
	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read

	set b, [FLOPPY__MBR__HEAD]					; sector
	set [FLOPPY__MBR__HEAD], a
	jsr floppy__sector__write
	
	;---------------------------------------
	; struct handle *inode (sector, size)
	;---------------------------------------
	set push, 2
	set push, TYPE_TUPLE
	jsr array_create
	set [z-1], x

	set c, [x]									; inode

	set push, b									; sector
	jsr uint16_to_int
	set [c + INODE__SECTOR], x
	
	set push, [floppy__file__position]			; size
	jsr uint16_to_int
	set [c + INODE__SIZE], x

	set x, [z-1]
	set pc, postamble
  
;----------------------------------------------------------------
; struct handle *file__item__read_from_sector(uint16 sector)
;----------------------------------------------------------------
:floppy__item__read_from_sector
	set push, 1
	set push, 0
	jsr preamble
	
	set push, [z+10]
	jsr floppy__file__open		

	jsr floppy__item__deserialize
	
	set pc, postamble

;----------------------------------------------------------------
; struct handle *file__write(struct handle *item)
;----------------------------------------------------------------
:floppy__item__write_to_free_space
    set push, 1
    set push, 1
    jsr preamble

	;---------------------------------------
	; read mbr
	;---------------------------------------
	set push, FLOPPY__MBR__SECTOR 
	jsr floppy__sector__read

	set a, [FLOPPY__MBR__HEAD_SECTOR]		; first sector

	;---------------------------------------
	; write file to free space
	;---------------------------------------
	set push, a
	jsr floppy__file__open

	; serialize object
    set push, [z+10]
    jsr floppy__item__serialize

	set b, [floppy__file__position]			; file length

	;---------------------------------------
	; terminate file and update list of free sectors
	;---------------------------------------
	jsr floppy__file__close
	
	;---------------------------------------
	; return struct handle *inode (sector, size)
	;---------------------------------------
	set push, 2
	set push, TYPE_TUPLE
	jsr array_create
	set [z-1], x

	set c, [x]

	set push, a					; sector
	jsr uint16_to_int
	set [c + INODE_SECTOR], x
	
	set push, b					; length
	jsr uint16_to_int
	set [c + INODE_SIZE], x

	set pc, postamble

;----------------------------------------------------------------
:floppy__file__open
;----------------------------------------------------------------
	set push, [sp + 1]
    jsr floppy__sector__read

	; initialize file position
    set [floppy__file__position], 0
    
    set [sp], pop
    set pc, pop

;----------------------------------------------------------------
; LOW LEVEL SUBROUTINES
;----------------------------------------------------------------

;----------------------------------------------------------------
:floppy__file__write_word
;----------------------------------------------------------------
	ifl [floppy__buffer__position], MEM_FLOPPY_END
        set pc, floppy__file__write_word__to_buffer

    jsr floppy__sector__write

    ; read the next sector to memory buffer
    set push, [FLOPPY__SECTOR__NEXT_SECTOR]
    jsr floppy__sector__read

:floppy__file__write_word__to_buffer
    set x, [floppy__buffer__position]
    set [x], [sp + 1]

    add [floppy__buffer__position], 1
    add [floppy__file__position], 1
    
	set [sp], pop
    set pc, pop

;----------------------------------------------------------------
:floppy__file__read_word
;----------------------------------------------------------------
	ifl [floppy__buffer__position], MEM_FLOPPY_END
        set pc, floppy__file__read_word__from_buffer

    ; read the next sector to memory buffer
    set push, [FLOPPY__SECTOR__NEXT_SECTOR]
    jsr floppy__sector__read

:floppy__file__read_word__from_buffer
    set c, [floppy__buffer__position]
    set c, [c]

    add [floppy__buffer__position], 1
    add [floppy__file__position], 1

    set pc, pop

;----------------------------------------------------------------
; void floppy__sector__write()
;----------------------------------------------------------------
:floppy__sector__write
    set push, 0
    set push, 0
    jsr preamble

	;---------------------------------------
	; initiate write
	;---------------------------------------
	set a, 3
	set x, [floppy__sector__current]
	set y, MEM_FLOPPY_START
	hwi [floppy]
	;---------------------------------------

	jsr floppy__status__wait_ready

    set pc, postamble

;----------------------------------------------------------------
; void file__sector__read(uint16 _sector)
;----------------------------------------------------------------
:floppy__sector__read
    set push, 1
    set push, 0
    jsr preamble
    
	;---------------------------------------
	; initiate read
	;---------------------------------------
	set a, 2					; read from floppy
	set x, [z + 10]				; _sector
	set y, MEM_FLOPPY_START
	hwi [floppy]
	;---------------------------------------
	
	; poll for ready
	jsr floppy__status__wait_ready

	; update current sector
    set [floppy__sector__current], [z + 10]

	; reset buffer pointer
    set [floppy__buffer__position], FLOPPY__SECTOR__DATA_START

    set pc, postamble

;----------------------------------------------------------------
; struct handle *floppy__sector__free(uint16 _sector)
;----------------------------------------------------------------
:floppy__sector__free
    set push, 1
    set push, 0
    jsr preamble

	set push, FLOPPY__MBR__SECTOR
	jsr floppy__sector__read

	set push, [FLOPPY__MBR__TAIL]
	jsr floppy__sector__read

	set [FLOPPY__SECTOR__NEXT], [z + 10]
	jsr floppy__sector__write

	set pc, postamble

;----------------------------------------------------------------
:floppy__status__wait_ready
;----------------------------------------------------------------
	set a, 0
:floppy__status__wait_ready__loop
	hwi [floppy]
	ife b, FLOPPY__STATE__BUSY
		set pc, floppy__status__wait_ready__loop

	set pc, pop
	
